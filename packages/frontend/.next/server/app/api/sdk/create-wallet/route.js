/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/sdk/create-wallet/route";
exports.ids = ["app/api/sdk/create-wallet/route"];
exports.modules = {

/***/ "(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fsdk%2Fcreate-wallet%2Froute&page=%2Fapi%2Fsdk%2Fcreate-wallet%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fsdk%2Fcreate-wallet%2Froute.ts&appDir=%2FUsers%2Fadmin%2FDocuments%2Fprojects%2Fmycelium-sdk%2Fpackages%2Ffrontend%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fadmin%2FDocuments%2Fprojects%2Fmycelium-sdk%2Fpackages%2Ffrontend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fsdk%2Fcreate-wallet%2Froute&page=%2Fapi%2Fsdk%2Fcreate-wallet%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fsdk%2Fcreate-wallet%2Froute.ts&appDir=%2FUsers%2Fadmin%2FDocuments%2Fprojects%2Fmycelium-sdk%2Fpackages%2Ffrontend%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fadmin%2FDocuments%2Fprojects%2Fmycelium-sdk%2Fpackages%2Ffrontend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/../../node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/../../node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/../../node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/../../node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/../../node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/../../node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/../../node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/../../node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/../../node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/../../node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/../../node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/../../node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/../../node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/../../node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var _Users_admin_Documents_projects_mycelium_sdk_packages_frontend_src_app_api_sdk_create_wallet_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/app/api/sdk/create-wallet/route.ts */ \"(rsc)/./src/app/api/sdk/create-wallet/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/sdk/create-wallet/route\",\n        pathname: \"/api/sdk/create-wallet\",\n        filename: \"route\",\n        bundlePath: \"app/api/sdk/create-wallet/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"/Users/admin/Documents/projects/mycelium-sdk/packages/frontend/src/app/api/sdk/create-wallet/route.ts\",\n    nextConfigOutput,\n    userland: _Users_admin_Documents_projects_mycelium_sdk_packages_frontend_src_app_api_sdk_create_wallet_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/sdk/create-wallet/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1hcHAtbG9hZGVyL2luZGV4LmpzP25hbWU9YXBwJTJGYXBpJTJGc2RrJTJGY3JlYXRlLXdhbGxldCUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGc2RrJTJGY3JlYXRlLXdhbGxldCUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnNkayUyRmNyZWF0ZS13YWxsZXQlMkZyb3V0ZS50cyZhcHBEaXI9JTJGVXNlcnMlMkZhZG1pbiUyRkRvY3VtZW50cyUyRnByb2plY3RzJTJGbXljZWxpdW0tc2RrJTJGcGFja2FnZXMlMkZmcm9udGVuZCUyRnNyYyUyRmFwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9JTJGVXNlcnMlMkZhZG1pbiUyRkRvY3VtZW50cyUyRnByb2plY3RzJTJGbXljZWxpdW0tc2RrJTJGcGFja2FnZXMlMkZmcm9udGVuZCZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCZpc0dsb2JhbE5vdEZvdW5kRW5hYmxlZD0hIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ3FCO0FBQ2Q7QUFDUztBQUNPO0FBQ0s7QUFDbUM7QUFDakQ7QUFDTztBQUNmO0FBQ3NDO0FBQ3pCO0FBQ007QUFDQztBQUNoQjtBQUNnRTtBQUNsSTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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YztBQUNoQywrQkFBK0IsNEVBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBGQUFxQjtBQUNsRTtBQUNBLGtCQUFrQiw2RUFBWTtBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsZ0ZBQWM7QUFDM0YsaUNBQWlDLFFBQVEsRUFBRSxRQUFRO0FBQ25ELDBCQUEwQix1RUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBLDRDQUE0Qyw2RkFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyRkFBbUI7QUFDckQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkVBQVk7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0IHsgZ2V0UmVxdWVzdE1ldGEgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0LW1ldGFcIjtcbmltcG9ydCB7IGdldFRyYWNlciwgU3BhbktpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvdHJhY2VyXCI7XG5pbXBvcnQgeyBub3JtYWxpemVBcHBQYXRoIH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hcHAtcGF0aHNcIjtcbmltcG9ydCB7IE5vZGVOZXh0UmVxdWVzdCwgTm9kZU5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Jhc2UtaHR0cC9ub2RlXCI7XG5pbXBvcnQgeyBOZXh0UmVxdWVzdEFkYXB0ZXIsIHNpZ25hbEZyb21Ob2RlUmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvbmV4dC1yZXF1ZXN0XCI7XG5pbXBvcnQgeyBCYXNlU2VydmVyU3BhbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS9jb25zdGFudHNcIjtcbmltcG9ydCB7IGdldFJldmFsaWRhdGVSZWFzb24gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9pbnN0cnVtZW50YXRpb24vdXRpbHNcIjtcbmltcG9ydCB7IHNlbmRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3NlbmQtcmVzcG9uc2VcIjtcbmltcG9ydCB7IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycywgdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3dlYi91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0Q2FjaGVDb250cm9sSGVhZGVyIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL2NhY2hlLWNvbnRyb2xcIjtcbmltcG9ydCB7IElORklOSVRFX0NBQ0hFLCBORVhUX0NBQ0hFX1RBR1NfSEVBREVSIH0gZnJvbSBcIm5leHQvZGlzdC9saWIvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBOb0ZhbGxiYWNrRXJyb3IgfSBmcm9tIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvbm8tZmFsbGJhY2stZXJyb3IuZXh0ZXJuYWxcIjtcbmltcG9ydCB7IENhY2hlZFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3Jlc3BvbnNlLWNhY2hlXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL2FkbWluL0RvY3VtZW50cy9wcm9qZWN0cy9teWNlbGl1bS1zZGsvcGFja2FnZXMvZnJvbnRlbmQvc3JjL2FwcC9hcGkvc2RrL2NyZWF0ZS13YWxsZXQvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL3Nkay9jcmVhdGUtd2FsbGV0L3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvc2RrL2NyZWF0ZS13YWxsZXRcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL3Nkay9jcmVhdGUtd2FsbGV0L3JvdXRlXCJcbiAgICB9LFxuICAgIGRpc3REaXI6IHByb2Nlc3MuZW52Ll9fTkVYVF9SRUxBVElWRV9ESVNUX0RJUiB8fCAnJyxcbiAgICByZWxhdGl2ZVByb2plY3REaXI6IHByb2Nlc3MuZW52Ll9fTkVYVF9SRUxBVElWRV9QUk9KRUNUX0RJUiB8fCAnJyxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL2Zyb250ZW5kL3NyYy9hcHAvYXBpL3Nkay9jcmVhdGUtd2FsbGV0L3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxLCByZXMsIGN0eCkge1xuICAgIHZhciBfbmV4dENvbmZpZ19leHBlcmltZW50YWw7XG4gICAgbGV0IHNyY1BhZ2UgPSBcIi9hcGkvc2RrL2NyZWF0ZS13YWxsZXQvcm91dGVcIjtcbiAgICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gdG8gcHJvY2VzcyBkeW5hbWljIHJvdXRlcyBwcm9wZXJseVxuICAgIC8vIFRPRE86IGZpeCB0dXJib3BhY2sgcHJvdmlkaW5nIGRpZmZlcmluZyB2YWx1ZSBmcm9tIHdlYnBhY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHNyY1BhZ2UgPSBzcmNQYWdlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcnKSB8fCAnLyc7XG4gICAgfSBlbHNlIGlmIChzcmNQYWdlID09PSAnL2luZGV4Jykge1xuICAgICAgICAvLyB3ZSBhbHdheXMgbm9ybWFsaXplIC9pbmRleCBzcGVjaWZpY2FsbHlcbiAgICAgICAgc3JjUGFnZSA9ICcvJztcbiAgICB9XG4gICAgY29uc3QgbXVsdGlab25lRHJhZnRNb2RlID0gcHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERTtcbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlLFxuICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGVcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgcGFyYW1zLCBuZXh0Q29uZmlnLCBpc0RyYWZ0TW9kZSwgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQsIGlzT25EZW1hbmRSZXZhbGlkYXRlLCByZXZhbGlkYXRlT25seUdlbmVyYXRlZCwgcmVzb2x2ZWRQYXRobmFtZSB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICBjb25zdCBub3JtYWxpemVkU3JjUGFnZSA9IG5vcm1hbGl6ZUFwcFBhdGgoc3JjUGFnZSk7XG4gICAgbGV0IGlzSXNyID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSB8fCBwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgIGlmIChpc0lzciAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY29uc3QgaXNQcmVyZW5kZXJlZCA9IEJvb2xlYW4ocHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW3Jlc29sdmVkUGF0aG5hbWVdKTtcbiAgICAgICAgY29uc3QgcHJlcmVuZGVySW5mbyA9IHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdO1xuICAgICAgICBpZiAocHJlcmVuZGVySW5mbykge1xuICAgICAgICAgICAgaWYgKHByZXJlbmRlckluZm8uZmFsbGJhY2sgPT09IGZhbHNlICYmICFpc1ByZXJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vRmFsbGJhY2tFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjYWNoZUtleSA9IG51bGw7XG4gICAgaWYgKGlzSXNyICYmICFyb3V0ZU1vZHVsZS5pc0RldiAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY2FjaGVLZXkgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAvLyBlbnN1cmUgL2luZGV4IGFuZCAvIGlzIG5vcm1hbGl6ZWQgdG8gb25lIGtleVxuICAgICAgICBjYWNoZUtleSA9IGNhY2hlS2V5ID09PSAnL2luZGV4JyA/ICcvJyA6IGNhY2hlS2V5O1xuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSA9IC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50LCB3ZSBhbHdheXMgc3VwcG9ydCBkeW5hbWljIEhUTUxcbiAgICByb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAvLyBJZiB0aGlzIGlzIG5vdCBTU0cgb3IgZG9lcyBub3QgaGF2ZSBzdGF0aWMgcGF0aHMsIHRoZW4gaXQgc3VwcG9ydHNcbiAgICAvLyBkeW5hbWljIEhUTUwuXG4gICAgIWlzSXNyO1xuICAgIC8vIFRoaXMgaXMgYSByZXZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWNcbiAgICAvLyBwYWdlIGFuZCBpdCBpcyBub3QgYmVpbmcgcmVzdW1lZCBmcm9tIGEgcG9zdHBvbmVkIHJlbmRlciBhbmRcbiAgICAvLyBpdCBpcyBub3QgYSBkeW5hbWljIFJTQyByZXF1ZXN0IHRoZW4gaXQgaXMgYSByZXZhbGlkYXRpb25cbiAgICAvLyByZXF1ZXN0LlxuICAgIGNvbnN0IGlzUmV2YWxpZGF0ZSA9IGlzSXNyICYmICFzdXBwb3J0c0R5bmFtaWNSZXNwb25zZTtcbiAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsOiB7XG4gICAgICAgICAgICAgICAgY2FjaGVDb21wb25lbnRzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNhY2hlQ29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgYXV0aEludGVycnVwdHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuYXV0aEludGVycnVwdHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UsXG4gICAgICAgICAgICBpbmNyZW1lbnRhbENhY2hlOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbmNyZW1lbnRhbENhY2hlJyksXG4gICAgICAgICAgICBjYWNoZUxpZmVQcm9maWxlczogKF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbCA9IG5leHRDb25maWcuZXhwZXJpbWVudGFsKSA9PSBudWxsID8gdm9pZCAwIDogX25leHRDb25maWdfZXhwZXJpbWVudGFsLmNhY2hlTGlmZSxcbiAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChjYik9PntcbiAgICAgICAgICAgICAgICByZXMub24oJ2Nsb3NlJywgY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQWZ0ZXJUYXNrRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uSW5zdHJ1bWVudGF0aW9uUmVxdWVzdEVycm9yOiAoZXJyb3IsIF9yZXF1ZXN0LCBlcnJvckNvbnRleHQpPT5yb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVycm9yLCBlcnJvckNvbnRleHQsIHJvdXRlclNlcnZlckNvbnRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXJlZENvbnRleHQ6IHtcbiAgICAgICAgICAgIGJ1aWxkSWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9kZU5leHRSZXEgPSBuZXcgTm9kZU5leHRSZXF1ZXN0KHJlcSk7XG4gICAgY29uc3Qgbm9kZU5leHRSZXMgPSBuZXcgTm9kZU5leHRSZXNwb25zZShyZXMpO1xuICAgIGNvbnN0IG5leHRSZXEgPSBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbU5vZGVOZXh0UmVxdWVzdChub2RlTmV4dFJlcSwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZShyZXMpKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlTW9kdWxlLmhhbmRsZShuZXh0UmVxLCBjb250ZXh0KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKGN1cnJlbnRTcGFuKT0+e1xuICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VHZW5lcmF0b3IgPSBhc3luYyAoeyBwcmV2aW91c0NhY2hlRW50cnkgfSk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiYgaXNPbkRlbWFuZFJldmFsaWRhdGUgJiYgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQgJiYgIXByZXZpb3VzQ2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBhbHdheXMgc2V0cyB0aGlzIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCAnUkVWQUxJREFURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW52b2tlUm91dGVNb2R1bGUoY3VycmVudFNwYW4pO1xuICAgICAgICAgICAgICAgICAgICByZXEuZmV0Y2hNZXRyaWNzID0gY29udGV4dC5yZW5kZXJPcHRzLmZldGNoTWV0cmljcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlbmRpbmdXYWl0VW50aWwgPSBjb250ZXh0LnJlbmRlck9wdHMucGVuZGluZ1dhaXRVbnRpbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB1c2luZyBwcm92aWRlZCB3YWl0VW50aWwgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHdlIGZhbGxiYWNrIHRvIHNlbmRSZXNwb25zZSdzIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nV2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LndhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC53YWl0VW50aWwocGVuZGluZ1dhaXRVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dhaXRVbnRpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVRhZ3MgPSBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkVGFncztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgZm9yIGEgc3RhdGljIHJlc3BvbnNlLCB3ZSBjYW4gY2FjaGUgaXQgc28gbG9uZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIG5vdCBlZGdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBoZWFkZXJzIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXSA9IGNhY2hlVGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgYmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBibG9iLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gdHlwZW9mIGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZSA+PSBJTkZJTklURV9DQUNIRSA/IGZhbHNlIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA+PSBJTkZJTklURV9DQUNIRSA/IHVuZGVmaW5lZCA6IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNhY2hlIGVudHJ5IGZvciB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBCdWZmZXIuZnJvbShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCByZXNwb25zZSB3aXRob3V0IGNhY2hpbmcgaWYgbm90IElTUlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgcmVzcG9uc2UsIGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBiYWNrZ3JvdW5kIHJldmFsaWRhdGUgd2UgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgZXJyb3IgaGVyZSBhcyBpdCB3b24ndCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzQ2FjaGVFbnRyeS5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVyciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcktpbmQ6ICdBcHAgUm91dGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVBhdGg6IHNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJvdXRlclNlcnZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJvdXRlTW9kdWxlLmhhbmRsZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjcmVhdGUgYSBjYWNoZUVudHJ5IGZvciBJU1JcbiAgICAgICAgICAgIGlmICghaXNJc3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlLmtpbmQpICE9PSBDYWNoZWRSb3V0ZUtpbmQuQVBQX1JPVVRFKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQ6IGFwcC1yb3V0ZSByZWNlaXZlZCBpbnZhbGlkIGNhY2hlIGVudHJ5ICR7Y2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZH1gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU3MDFcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCBpc09uRGVtYW5kUmV2YWxpZGF0ZSA/ICdSRVZBTElEQVRFRCcgOiBjYWNoZUVudHJ5LmlzTWlzcyA/ICdNSVNTJyA6IGNhY2hlRW50cnkuaXNTdGFsZSA/ICdTVEFMRScgOiAnSElUJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcmFmdCBtb2RlIHNob3VsZCBuZXZlciBiZSBjYWNoZWRcbiAgICAgICAgICAgIGlmIChpc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAncHJpdmF0ZSwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtYXgtYWdlPTAsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKCEoZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc0lzcikpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmRlbGV0ZShORVhUX0NBQ0hFX1RBR1NfSEVBREVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNhY2hlIGNvbnRyb2wgaXMgYWxyZWFkeSBzZXQgb24gdGhlIHJlc3BvbnNlIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBvdmVycmlkZSBpdCB0byBhbGxvdyB1c2VycyB0byBjdXN0b21pemUgaXQgdmlhIG5leHQuY29uZmlnXG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSAmJiAhaGVhZGVycy5nZXQoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdDYWNoZS1Db250cm9sJywgZ2V0Q2FjaGVDb250cm9sSGVhZGVyKGNhY2hlRW50cnkuY2FjaGVDb250cm9sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UoY2FjaGVFbnRyeS52YWx1ZS5ib2R5LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlRW50cnkudmFsdWUuc3RhdHVzIHx8IDIwMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVSZXNwb25zZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVSZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZW4ndCB3cmFwcGVkIGJ5IGJhc2Utc2VydmVyIGhhbmRsZSBoZXJlXG4gICAgICAgIGlmICghYWN0aXZlU3BhbiAmJiAhKGVyciBpbnN0YW5jZW9mIE5vRmFsbGJhY2tFcnJvcikpIHtcbiAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogbm9ybWFsaXplZFNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiwgdGhyb3cgdGhlIGVycm9yIGFnYWluLlxuICAgICAgICBpZiAoaXNJc3IpIHRocm93IGVycjtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZW5kIGEgNTAwIHJlc3BvbnNlLlxuICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fsdk%2Fcreate-wallet%2Froute&page=%2Fapi%2Fsdk%2Fcreate-wallet%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fsdk%2Fcreate-wallet%2Froute.ts&appDir=%2FUsers%2Fadmin%2FDocuments%2Fprojects%2Fmycelium-sdk%2Fpackages%2Ffrontend%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fadmin%2FDocuments%2Fprojects%2Fmycelium-sdk%2Fpackages%2Ffrontend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \**********************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/../sdk/dist/index.js":
/*!****************************!*\
  !*** ../sdk/dist/index.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MyceliumSDK: () => (/* binding */ MyceliumSDK),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/clients/createPublicClient.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/clients/transports/http.js\");\n/* harmony import */ var viem_account_abstraction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! viem/account-abstraction */ \"(rsc)/../sdk/node_modules/viem/_esm/account-abstraction/clients/createBundlerClient.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../sdk/node_modules/viem/_esm/chains/index.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../sdk/node_modules/viem/_esm/chains/definitions/unichain.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/utils/data/pad.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/utils/abi/encodeFunctionData.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/constants/abis.js\");\n/* harmony import */ var viem_account_abstraction__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! viem/account-abstraction */ \"(rsc)/../sdk/node_modules/viem/_esm/account-abstraction/accounts/implementations/toCoinbaseSmartAccount.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/utils/unit/formatEther.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/utils/unit/formatUnits.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../sdk/node_modules/viem/_esm/chains/definitions/mainnet.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../sdk/node_modules/viem/_esm/chains/definitions/base.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../sdk/node_modules/viem/_esm/chains/definitions/baseSepolia.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../sdk/node_modules/viem/_esm/chains/definitions/sepolia.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/utils/unit/parseUnits.js\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/utils/address/getAddress.js\");\n/* harmony import */ var _privy_io_server_auth_viem__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @privy-io/server-auth/viem */ \"(rsc)/../sdk/node_modules/@privy-io/server-auth/dist/esm/viem.mjs\");\n/* harmony import */ var viem__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! viem */ \"(rsc)/../sdk/node_modules/viem/_esm/clients/createWalletClient.js\");\n/* harmony import */ var _privy_io_server_auth__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @privy-io/server-auth */ \"(rsc)/../sdk/node_modules/@privy-io/server-auth/dist/esm/index.mjs\");\n// src/tools/ChainManager.ts\n\n\n// src/utils/chains.ts\n\n\nvar chainById = Object.values(viem_chains__WEBPACK_IMPORTED_MODULE_0__).reduce((acc, maybeChain)=>{\n    if (maybeChain && typeof maybeChain === \"object\" && \"id\" in maybeChain && typeof maybeChain.id === \"number\" && \"name\" in maybeChain) {\n        const chain = maybeChain;\n        acc[chain.id] = chain;\n    }\n    return acc;\n}, {});\n// src/tools/ChainManager.ts\nvar ChainManager = class {\n    /**\n   * Initialize the ChainManager with chain configurations\n   * @param chains - Array of chain configurations\n   */ constructor(chains){\n        this.chainConfigs = chains;\n        this.publicClients = this.createPublicClients(chains);\n    }\n    /**\n   * Get public client for a specific chain\n   * @param chainId - The chain ID to retrieve the public client for\n   * @returns PublicClient instance for the specified chain\n   * @throws Error if no client is configured for the chain ID\n   */ getPublicClient(chainId) {\n        const client = this.publicClients.get(chainId);\n        if (!client) {\n            throw new Error(`No public client configured for chain ID: ${chainId}`);\n        }\n        return client;\n    }\n    /**\n   * Get bundler client for a specific chain\n   * @param chainId - The chain ID to retrieve the bundler client for\n   * @param account - SmartAccount to use with the bundler client\n   * @returns BundlerClient instance for the specified chain\n   * @throws Error if no bundler URL is configured for the chain ID\n   */ getBundlerClient(chainId, account) {\n        const bundlerUrl = this.getBundlerUrl(chainId);\n        if (!bundlerUrl) {\n            throw new Error(`No bundler URL configured for chain ID: ${chainId}`);\n        }\n        const client = (0,viem__WEBPACK_IMPORTED_MODULE_1__.createPublicClient)({\n            chain: this.getChain(chainId),\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_2__.http)(bundlerUrl)\n        });\n        return (0,viem_account_abstraction__WEBPACK_IMPORTED_MODULE_3__.createBundlerClient)({\n            account,\n            client,\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_2__.http)(bundlerUrl),\n            chain: this.getChain(chainId)\n        });\n    }\n    /**\n   * Get RPC URL for a specific chain\n   * @param chainId - The chain ID to retrieve the RPC URL for\n   * @returns RPC URL as a string\n   * @throws Error if no chain config is found for the chain ID\n   */ getRpcUrl(chainId) {\n        const chainConfig = this.chainConfigs.find((c)=>c.chainId === chainId);\n        if (!chainConfig) {\n            throw new Error(`No chain config found for chain ID: ${chainId}`);\n        }\n        return chainConfig.rpcUrl;\n    }\n    /**\n   * Get bundler URL for a specific chain\n   * @param chainId - The chain ID to retrieve the bundler URL for\n   * @returns Bundler URL as a string or undefined if not configured\n   * @throws Error if no chain config is found for the chain ID\n   */ getBundlerUrl(chainId) {\n        const chainConfig = this.chainConfigs.find((c)=>c.chainId === chainId);\n        if (!chainConfig) {\n            throw new Error(`No chain config found for chain ID: ${chainId}`);\n        }\n        return chainConfig.bundlerUrl;\n    }\n    /**\n   * Get chain information for a specific chain ID\n   * @param chainId - The chain ID to retrieve information for\n   * @returns Chain object containing chain details\n   */ getChain(chainId) {\n        const chain = chainById[chainId];\n        if (!chain) {\n            throw new Error(`Chain not found for ID: ${chainId}`);\n        }\n        return chain;\n    }\n    /**\n   * Get all supported chain IDs\n   * @returns Array of supported chain IDs\n   */ getSupportedChains() {\n        return this.chainConfigs.map((c)=>c.chainId);\n    }\n    /**\n   * Create public clients for all configured chains\n   * @param chains - Array of chain configurations\n   * @returns Map of chain IDs to their corresponding public clients\n   * @throws Error if a chain is not found or already configured\n   */ createPublicClients(chains) {\n        const clients = /* @__PURE__ */ new Map();\n        for (const chainConfig of chains){\n            const chain = chainById[chainConfig.chainId];\n            if (!chain) {\n                throw new Error(`Chain not found for ID: ${chainConfig.chainId}`);\n            }\n            if (clients.has(chainConfig.chainId)) {\n                throw new Error(`Public client already configured for chain ID: ${chainConfig.chainId}`);\n            }\n            const client = (0,viem__WEBPACK_IMPORTED_MODULE_1__.createPublicClient)({\n                chain,\n                transport: (0,viem__WEBPACK_IMPORTED_MODULE_2__.http)(chainConfig.rpcUrl)\n            });\n            clients.set(chainConfig.chainId, client);\n        }\n        return clients;\n    }\n};\n// src/wallet/base/providers/SmartWalletProvider.ts\nvar SmartWalletProvider = class {\n};\n// src/wallet/WalletNamespace.ts\nvar WalletNamespace = class {\n    constructor(provider){\n        this.provider = provider;\n    }\n    /**\n   * Get direct access to the embedded wallet provider\n   * @description Provides direct access to the underlying embedded wallet provider when\n   * advanced functionality beyond the unified interface is needed\n   * @returns The configured embedded wallet provider instance\n   */ get embeddedWalletProvider() {\n        return this.provider.embeddedWalletProvider;\n    }\n    /**\n   * Get direct access to the smart wallet provider\n   * @description Provides direct access to the underlying smart wallet provider when\n   * advanced functionality beyond the unified interface is needed\n   * @returns The configured smart wallet provider instance\n   */ get smartWalletProvider() {\n        return this.provider.smartWalletProvider;\n    }\n    /**\n   * Create a new embedded wallet\n   * @description Creates only an embedded wallet using the configured embedded wallet provider.\n   * @returns Promise resolving to the created embedded wallet instance\n   */ async createEmbeddedWallet() {\n        return this.provider.createEmbeddedWallet();\n    }\n    /**\n   * Create a new smart wallet\n   * @description Creates only a smart wallet using the configured smart wallet provider.\n   * This is useful when you already have a signer and want to create a smart wallet without\n   * creating an embedded wallet. You must provide your own signer and owners array.\n   * @param params - Smart wallet creation parameters\n   * @param params.owners - Array of owners for the smart wallet (addresses or WebAuthn public keys)\n   * @param params.signer - Local account used for signing transactions\n   * @param params.nonce - Optional nonce for smart wallet address generation (defaults to 0)\n   * @returns Promise resolving to the created smart wallet instance\n   */ async createSmartWallet(params) {\n        return this.provider.createSmartWallet(params);\n    }\n    /**\n   * Create a new smart wallet with embedded wallet as signer\n   * @description Creates both an embedded wallet and a smart wallet, with the embedded wallet\n   * automatically added as one of the owners/signers of the smart wallet.\n   * @param params - Optional wallet creation parameters\n   * @param params.owners - Optional array of additional owners for the smart wallet. The embedded wallet will be added to this array at the specified index.\n   * @param params.embeddedWalletIndex - Optional index where the embedded wallet should be inserted in the owners array. If not specified, embedded wallet is added to the end of the array.\n   * @param params.nonce - Optional nonce for smart wallet address generation (defaults to 0)\n   * @returns Promise resolving to the created smart wallet instance\n   */ async createWalletWithEmbeddedSigner(params) {\n        return this.provider.createWalletWithEmbeddedSigner(params);\n    }\n    /**\n   * Get an existing smart wallet using embedded wallet as signer\n   * @description Retrieves an embedded wallet by walletId and uses it as the signer to get\n   * the corresponding smart wallet. If neither walletAddress nor deploymentOwners is provided,\n   * defaults to using the embedded wallet as the single owner. This is useful when you have\n   * an embedded wallet ID and want to access the associated smart wallet functionality.\n   * @param params - Wallet retrieval parameters\n   * @param params.walletId - ID of the embedded wallet to use as signer\n   * @param params.deploymentOwners - Optional array of original deployment owners for smart wallet address calculation. If not provided and walletAddress is also not provided, defaults to using the embedded wallet as single owner.\n   * @param params.signerOwnerIndex - Current index of the signer in the smart wallet's current owners array (used for transaction signing). Defaults to 0 if not specified. This may differ from the original deployment index if owners have been modified.\n   * @param params.walletAddress - Optional explicit smart wallet address (skips address calculation)\n   * @param params.nonce - Optional nonce used during smart wallet creation\n   * @returns Promise resolving to the smart wallet instance with embedded wallet as signer\n   * @throws Error if embedded wallet is not found\n   */ async getSmartWalletWithEmbeddedSigner(params) {\n        return this.provider.getSmartWalletWithEmbeddedSigner(params);\n    }\n    /**\n   * Get an existing embedded wallet\n   * @description Retrieves an embedded wallet by walletId. This is useful when you have an embedded wallet ID and\n   * want to access the associated embedded wallet functionality.\n   * @param params - Wallet retrieval parameters\n   * @param params.walletId - ID of the embedded wallet to retrieve\n   * @returns Promise resolving to the embedded wallet instance\n   */ async getEmbeddedWallet(params) {\n        return this.provider.getEmbeddedWallet(params);\n    }\n    /**\n   * Get an existing smart wallet with a provided signer\n   * @description Retrieves a smart wallet using a directly provided signer. This is useful when\n   * you already have a LocalAccount signer and want to access an existing smart wallet without\n   * going through the embedded wallet provider. Use this instead of getSmartWalletWithEmbeddedSigner\n   * when you have direct control over the signer.\n   * @param signer - Local account to use for signing transactions on the smart wallet\n   * @param getWalletParams - Wallet retrieval parameters\n   * @param getWalletParams.deploymentOwners - Array of original deployment owners for smart wallet address calculation. Required if walletAddress not provided. Must match the exact owners array used during wallet deployment.\n   * @param getWalletParams.signerOwnerIndex - Current index of the signer in the smart wallet's current owners array (used for transaction signing). Defaults to 0 if not specified. This may differ from the original deployment index if owners have been modified.\n   * @param getWalletParams.walletAddress - Optional explicit smart wallet address (skips address calculation)\n   * @param getWalletParams.nonce - Optional nonce used during smart wallet creation\n   * @returns Promise resolving to the smart wallet instance with the provided signer\n   * @throws Error if neither walletAddress nor deploymentOwners provided\n   */ async getSmartWallet(params) {\n        return this.provider.getSmartWallet(params);\n    }\n};\n// src/index.ts\n\n// src/wallet/providers/DefaultSmartWalletProvider.ts\n\n\n// src/abis/smartWalletFactory.ts\nvar smartWalletFactoryAbi = [\n    {\n        type: \"constructor\",\n        inputs: [\n            {\n                name: \"implementation_\",\n                type: \"address\",\n                internalType: \"address\"\n            }\n        ],\n        stateMutability: \"payable\"\n    },\n    {\n        type: \"function\",\n        name: \"createAccount\",\n        inputs: [\n            {\n                name: \"owners\",\n                type: \"bytes[]\",\n                internalType: \"bytes[]\"\n            },\n            {\n                name: \"nonce\",\n                type: \"uint256\",\n                internalType: \"uint256\"\n            }\n        ],\n        outputs: [\n            {\n                name: \"account\",\n                type: \"address\",\n                internalType: \"contract CoinbaseSmartWallet\"\n            }\n        ],\n        stateMutability: \"payable\"\n    },\n    {\n        type: \"function\",\n        name: \"getAddress\",\n        inputs: [\n            {\n                name: \"owners\",\n                type: \"bytes[]\",\n                internalType: \"bytes[]\"\n            },\n            {\n                name: \"nonce\",\n                type: \"uint256\",\n                internalType: \"uint256\"\n            }\n        ],\n        outputs: [\n            {\n                name: \"\",\n                type: \"address\",\n                internalType: \"address\"\n            }\n        ],\n        stateMutability: \"view\"\n    },\n    {\n        type: \"function\",\n        name: \"implementation\",\n        inputs: [],\n        outputs: [\n            {\n                name: \"\",\n                type: \"address\",\n                internalType: \"address\"\n            }\n        ],\n        stateMutability: \"view\"\n    },\n    {\n        type: \"function\",\n        name: \"initCodeHash\",\n        inputs: [],\n        outputs: [\n            {\n                name: \"\",\n                type: \"bytes32\",\n                internalType: \"bytes32\"\n            }\n        ],\n        stateMutability: \"view\"\n    },\n    {\n        type: \"event\",\n        name: \"AccountCreated\",\n        inputs: [\n            {\n                name: \"account\",\n                type: \"address\",\n                indexed: true,\n                internalType: \"address\"\n            },\n            {\n                name: \"owners\",\n                type: \"bytes[]\",\n                indexed: false,\n                internalType: \"bytes[]\"\n            },\n            {\n                name: \"nonce\",\n                type: \"uint256\",\n                indexed: false,\n                internalType: \"uint256\"\n            }\n        ],\n        anonymous: false\n    },\n    {\n        type: \"error\",\n        name: \"ImplementationUndeployed\",\n        inputs: []\n    },\n    {\n        type: \"error\",\n        name: \"OwnerRequired\",\n        inputs: []\n    }\n];\n// src/constants/addresses.ts\nvar smartWalletFactoryAddress = \"0xBA5ED110eFDBa3D005bfC882d75358ACBbB85842\";\n// src/wallet/DefaultSmartWallet.ts\n\n\n\n// src/tools/TokenBalance.ts\n\n// src/constants/tokens.ts\n\nvar SUPPORTED_TOKENS = {\n    ETH: {\n        symbol: \"ETH\",\n        name: \"Ethereum\",\n        decimals: 18,\n        addresses: {\n            [viem_chains__WEBPACK_IMPORTED_MODULE_4__.mainnet.id]: \"0x0000000000000000000000000000000000000000\",\n            [viem_chains__WEBPACK_IMPORTED_MODULE_5__.unichain.id]: \"0x0000000000000000000000000000000000000000\",\n            [viem_chains__WEBPACK_IMPORTED_MODULE_6__.base.id]: \"0x0000000000000000000000000000000000000000\",\n            [viem_chains__WEBPACK_IMPORTED_MODULE_7__.baseSepolia.id]: \"0x0000000000000000000000000000000000000000\",\n            [viem_chains__WEBPACK_IMPORTED_MODULE_8__.sepolia.id]: \"0x0000000000000000000000000000000000000000\"\n        }\n    },\n    USDC: {\n        symbol: \"USDC\",\n        name: \"USDC\",\n        decimals: 6,\n        addresses: {\n            [viem_chains__WEBPACK_IMPORTED_MODULE_4__.mainnet.id]: \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n            [viem_chains__WEBPACK_IMPORTED_MODULE_5__.unichain.id]: \"0x078d782b760474a361dda0af3839290b0ef57ad6\",\n            [viem_chains__WEBPACK_IMPORTED_MODULE_7__.baseSepolia.id]: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n            [viem_chains__WEBPACK_IMPORTED_MODULE_8__.sepolia.id]: \"0xf08A50178dfcDe18524640EA6618a1f965821715\"\n        }\n    }\n};\n// src/utils/tokens.ts\nfunction getTokenAddress(symbol, chainId) {\n    const token = SUPPORTED_TOKENS[symbol];\n    return token?.addresses[chainId] || null;\n}\n// src/tools/TokenBalance.ts\nasync function fetchETHBalance(chainManager, walletAddress) {\n    const supportedChains = chainManager.getSupportedChains();\n    const chainBalancePromises = supportedChains.map(async (chainId)=>{\n        const publicClient = chainManager.getPublicClient(chainId);\n        const balance = await publicClient.getBalance({\n            address: walletAddress\n        });\n        return {\n            chainId,\n            balance,\n            formattedBalance: (0,viem__WEBPACK_IMPORTED_MODULE_9__.formatEther)(balance)\n        };\n    });\n    const chainBalances = await Promise.all(chainBalancePromises);\n    const totalBalance = chainBalances.reduce((total, { balance })=>total + balance, 0n);\n    return {\n        symbol: \"ETH\",\n        totalBalance,\n        totalFormattedBalance: (0,viem__WEBPACK_IMPORTED_MODULE_9__.formatEther)(totalBalance),\n        chainBalances\n    };\n}\nasync function fetchERC20Balance(chainManager, walletAddress, token) {\n    const supportedChains = chainManager.getSupportedChains();\n    const chainsWithToken = supportedChains.filter((chainId)=>getTokenAddress(token.symbol, chainId));\n    const chainBalancePromises = chainsWithToken.map(async (chainId)=>{\n        const balance = await fetchERC20BalanceForChain(token, chainId, walletAddress, chainManager);\n        return {\n            chainId,\n            balance,\n            formattedBalance: (0,viem__WEBPACK_IMPORTED_MODULE_10__.formatUnits)(balance, token.decimals)\n        };\n    });\n    const chainBalances = await Promise.all(chainBalancePromises);\n    const totalBalance = chainBalances.reduce((total, { balance })=>total + balance, 0n);\n    return {\n        symbol: token.symbol,\n        totalBalance,\n        totalFormattedBalance: (0,viem__WEBPACK_IMPORTED_MODULE_10__.formatUnits)(totalBalance, token.decimals),\n        chainBalances\n    };\n}\nasync function fetchERC20BalanceForChain(token, chainId, walletAddress, chainManager) {\n    const tokenAddress = getTokenAddress(token.symbol, chainId);\n    if (!tokenAddress) {\n        throw new Error(`${token.symbol} not supported on chain ${chainId}`);\n    }\n    const publicClient = chainManager.getPublicClient(chainId);\n    if (token.symbol === \"ETH\") {\n        return publicClient.getBalance({\n            address: walletAddress\n        });\n    }\n    return publicClient.readContract({\n        address: tokenAddress,\n        abi: viem__WEBPACK_IMPORTED_MODULE_11__.erc20Abi,\n        functionName: \"balanceOf\",\n        args: [\n            walletAddress\n        ]\n    });\n}\n// src/utils/assets.ts\n\nfunction resolveAsset(asset, chainId) {\n    if (asset.startsWith(\"0x\")) {\n        const address2 = asset;\n        for (const [, tokenInfo2] of Object.entries(SUPPORTED_TOKENS)){\n            const tokenAddress = tokenInfo2.addresses[chainId];\n            if (tokenAddress && tokenAddress.toLowerCase() === address2.toLowerCase()) {\n                return {\n                    address: tokenAddress,\n                    symbol: tokenInfo2.symbol,\n                    decimals: tokenInfo2.decimals\n                };\n            }\n        }\n        throw new Error(`Unknown asset address: ${address2}. Please use a supported asset symbol like 'usdc' or add the token to SUPPORTED_TOKENS.`);\n    }\n    const normalizedSymbol = asset.toUpperCase();\n    const tokenInfo = SUPPORTED_TOKENS[normalizedSymbol];\n    if (!tokenInfo) {\n        const availableSymbols = Object.keys(SUPPORTED_TOKENS).join(\", \");\n        throw new Error(`Unsupported asset symbol: ${asset}. Supported assets: ${availableSymbols}`);\n    }\n    const address = getTokenAddress(normalizedSymbol, chainId);\n    if (!address) {\n        throw new Error(`Asset ${asset} is not supported on chain ${chainId}. Available chains: ${Object.keys(tokenInfo.addresses).join(\", \")}`);\n    }\n    return {\n        address,\n        symbol: tokenInfo.symbol,\n        decimals: tokenInfo.decimals\n    };\n}\nfunction parseAssetAmount(amount, decimals) {\n    const amountStr = amount.toString();\n    return (0,viem__WEBPACK_IMPORTED_MODULE_12__.parseUnits)(amountStr, decimals);\n}\n// src/wallet/base/wallets/SmartWallet.ts\nvar SmartWallet = class {\n};\n// src/wallet/DefaultSmartWallet.ts\nvar DefaultSmartWallet = class extends SmartWallet {\n    /**\n     * Create a Smart Wallet instance\n     * @param owners - Array of wallet owners (addresses or WebAuthn accounts)\n     * @param signer - Local account for signing transactions\n     * @param chainManager - Network management service\n  //    * @param lendProvider - Lending operations provider\n     * @param bundlerUrl - ERC-4337 bundler service URL\n     * @param deploymentAddress - Known wallet address (if already deployed)\n     * @param ownerIndex - Index of signer in owners array\n     * @param nonce - Nonce for address generation\n     */ constructor(owners, signer, chainManager, deploymentAddress, signerOwnerIndex, nonce){\n        super();\n        this.owners = owners;\n        this._signer = signer;\n        this.signerOwnerIndex = signerOwnerIndex;\n        this.deploymentAddress = deploymentAddress;\n        this.chainManager = chainManager;\n        this.nonce = nonce;\n    }\n    /**\n   * Get the signer account for this smart wallet\n   * @description Returns the LocalAccount instance used for signing transactions and UserOperations.\n   * This signer is used to authorize operations on behalf of the smart wallet.\n   * @returns The LocalAccount signer configured for this smart wallet\n   */ get signer() {\n        return this._signer;\n    }\n    /**\n   * Get the smart wallet address\n   * @description Returns the deployment address if known, otherwise calculates the deterministic\n   * address using CREATE2 based on owners and nonce.\n   * @returns Promise resolving to the wallet address\n   */ async getAddress() {\n        if (this.deploymentAddress) return this.deploymentAddress;\n        const owners_bytes = this.owners.map((owner)=>{\n            if (typeof owner === \"string\") return (0,viem__WEBPACK_IMPORTED_MODULE_13__.pad)(owner);\n            if (owner.type === \"webAuthn\") return owner.publicKey;\n            throw new Error(\"invalid owner type\");\n        });\n        const supportedChains = this.chainManager.getSupportedChains();\n        if (!supportedChains.length) {\n            throw new Error(\"No supported chains configured\");\n        }\n        const publicClient = this.chainManager.getPublicClient(supportedChains[0]);\n        const smartWalletAddress = await publicClient.readContract({\n            abi: smartWalletFactoryAbi,\n            address: smartWalletFactoryAddress,\n            functionName: \"getAddress\",\n            args: [\n                owners_bytes,\n                this.nonce || 0n\n            ]\n        });\n        return smartWalletAddress;\n    }\n    /**\n   * Create a Coinbase Smart Account instance\n   * @description Converts this wallet into a viem-compatible smart account for ERC-4337 operations.\n   * @param chainId - Target blockchain network ID\n   * @returns Coinbase Smart Account instance configured for the specified chain\n   */ async getCoinbaseSmartAccount(chainId) {\n        return (0,viem_account_abstraction__WEBPACK_IMPORTED_MODULE_14__.toCoinbaseSmartAccount)({\n            address: this.deploymentAddress,\n            ownerIndex: this.signerOwnerIndex,\n            client: this.chainManager.getPublicClient(chainId),\n            owners: [\n                this.signer\n            ],\n            nonce: this.nonce,\n            version: \"1.1\"\n        });\n    }\n    /**\n   * Get asset balances across all supported chains\n   * @description Fetches ETH and ERC20 token balances for this wallet across all supported networks.\n   * @returns Promise resolving to array of token balances with chain breakdown\n   */ async getBalance() {\n        const address = await this.getAddress();\n        const tokenBalancePromises = Object.values(SUPPORTED_TOKENS).map(async (token)=>{\n            return fetchERC20Balance(this.chainManager, address, token);\n        });\n        const ethBalancePromise = fetchETHBalance(this.chainManager, address);\n        return Promise.all([\n            ethBalancePromise,\n            ...tokenBalancePromises\n        ]);\n    }\n    //   /**\n    //    * Lend assets to a lending market\n    //    * @description Lends assets using the configured lending provider with human-readable amounts\n    //    * @param amount - Human-readable amount to lend (e.g. 1.5)\n    //    * @param asset - Asset symbol (e.g. 'usdc') or token address\n    //    * @param marketId - Optional specific market ID or vault name\n    //    * @param options - Optional lending configuration\n    //    * @returns Promise resolving to lending transaction details\n    //    * @throws Error if no lending provider is configured\n    //    */\n    //   async lend(\n    //     amount: number,\n    //     asset: AssetIdentifier,\n    //     chainId: SupportedChainId,\n    //     marketId?: string,\n    //     options?: LendOptions\n    //   ): Promise<LendTransaction> {\n    //     // Parse human-readable inputs\n    //     const { amount: parsedAmount, asset: resolvedAsset } = parseLendParams(\n    //       amount,\n    //       asset,\n    //       chainId\n    //     );\n    //     const address = await this.getAddress();\n    //     // Set receiver to wallet address if not specified\n    //     const lendOptions: LendOptions = {\n    //       ...options,\n    //       receiver: options?.receiver || address,\n    //     };\n    //     const result = await this.lendProvider.deposit(\n    //       resolvedAsset.address,\n    //       parsedAmount,\n    //       marketId,\n    //       lendOptions\n    //     );\n    //     return result;\n    //   }\n    /**\n   * Send a transaction via ERC-4337\n   * @description Executes a transaction using the smart wallet with automatic gas sponsorship.\n   * The transaction is sent as a UserOperation through the bundler service.\n   * @param transactionData - Transaction details (to, value, data)\n   * @param chainId - Target blockchain network ID\n   * @returns Promise resolving to UserOperation hash\n   * @throws Error if transaction fails or validation errors occur\n   */ async send(transactionData, chainId) {\n        try {\n            const account = await this.getCoinbaseSmartAccount(chainId);\n            const bundlerClient = this.chainManager.getBundlerClient(chainId, account);\n            const calls = [\n                transactionData\n            ];\n            const hash = await bundlerClient.sendUserOperation({\n                account,\n                calls,\n                paymaster: true\n            });\n            await bundlerClient.waitForUserOperationReceipt({\n                hash\n            });\n            return hash;\n        } catch (error) {\n            throw new Error(`Failed to send transaction: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n        }\n    }\n    /**\n   * Fund a wallet with USDC using on-ramp service\n   * @description Funds the current wallet with USDC using on-ramp service\n   * @returns Return URL to the on-ramp service\n   */ fundUSDC() {}\n    /**\n   * Send tokens to another address\n   * @description Sends ETH or ERC20 tokens to a recipient address\n   * @param amount - Human-readable amount to send (e.g. 1.5)\n   * @param asset - Asset symbol (e.g. 'usdc', 'eth') or token address\n   * @param recipientAddress - Address to send to\n   * @returns Promise resolving to transaction data\n   * @throws Error if wallet is not initialized or asset is not supported\n   */ async sendTokens(amount, asset, recipientAddress) {\n        if (!recipientAddress) {\n            throw new Error(\"Recipient address is required\");\n        }\n        if (amount <= 0) {\n            throw new Error(\"Amount must be greater than 0\");\n        }\n        const chainId = viem_chains__WEBPACK_IMPORTED_MODULE_5__.unichain.id;\n        if (asset.toLowerCase() === \"eth\") {\n            const parsedAmount2 = parseAssetAmount(amount, 18);\n            return {\n                to: recipientAddress,\n                value: parsedAmount2,\n                data: \"0x\"\n            };\n        }\n        const resolvedAsset = resolveAsset(asset, chainId);\n        const parsedAmount = parseAssetAmount(amount, resolvedAsset.decimals);\n        const transferData = (0,viem__WEBPACK_IMPORTED_MODULE_15__.encodeFunctionData)({\n            abi: viem__WEBPACK_IMPORTED_MODULE_11__.erc20Abi,\n            functionName: \"transfer\",\n            args: [\n                recipientAddress,\n                parsedAmount\n            ]\n        });\n        return {\n            to: resolvedAsset.address,\n            value: 0n,\n            data: transferData\n        };\n    }\n};\n// src/wallet/providers/DefaultSmartWalletProvider.ts\nvar DefaultSmartWalletProvider = class extends SmartWalletProvider {\n    /** Provider for lending market operations */ //   private lendProvider: LendProvider;\n    /**\n   * Initialize the Smart Wallet Provider\n   * @param chainManager - Manages supported blockchain networks\n   * @param paymasterAndBundlerUrl - URL for ERC-4337 bundler and paymaster services\n   * @param lendProvider - Provider for lending market operations\n   */ constructor(chainManager){\n        super();\n        this.chainManager = chainManager;\n    }\n    /**\n   * Create a new smart wallet instance\n   * @description Creates a new smart wallet that will be deployed on first transaction.\n   * The wallet address is deterministically calculated from owners and nonce.\n   * @param owners - Array of wallet owners (addresses or WebAuthn public keys)\n   * @param signer - Local account used for signing transactions\n   * @param nonce - Optional nonce for address generation (defaults to 0)\n   * @returns Promise resolving to a new SmartWallet instance\n   */ async createWallet(params) {\n        const { owners, signer, nonce } = params;\n        return new DefaultSmartWallet(owners, signer, this.chainManager, //   this.lendProvider,\n        void 0, void 0, nonce);\n    }\n    /**\n   * Get the predicted smart wallet address\n   * @description Calculates the deterministic address where a smart wallet would be deployed\n   * given the specified owners and nonce. Uses CREATE2 for address prediction.\n   * @param params.owners - Array of wallet owners (addresses or WebAuthn public keys)\n   * @param params.nonce - Nonce for address generation (defaults to 0)\n   * @returns Promise resolving to the predicted wallet address\n   */ async getWalletAddress(params) {\n        const { owners, nonce = 0n } = params;\n        const owners_bytes = owners.map((owner)=>{\n            if (typeof owner === \"string\") return (0,viem__WEBPACK_IMPORTED_MODULE_13__.pad)(owner);\n            if (owner.type === \"webAuthn\") return owner.publicKey;\n            throw new Error(\"invalid owner type\");\n        });\n        const supportedChains = this.chainManager.getSupportedChains();\n        if (!supportedChains.length) {\n            throw new Error(\"No supported chains configured\");\n        }\n        const publicClient = this.chainManager.getPublicClient(supportedChains[0]);\n        const smartWalletAddress = await publicClient.readContract({\n            abi: smartWalletFactoryAbi,\n            address: smartWalletFactoryAddress,\n            functionName: \"getAddress\",\n            args: [\n                owners_bytes,\n                nonce\n            ]\n        });\n        return smartWalletAddress;\n    }\n    /**\n   * Get an existing smart wallet instance\n   * @description Creates a SmartWallet instance for an already deployed wallet.\n   * Use this when you know the wallet address and want to interact with it.\n   * @param params.walletAddress - Address of the deployed smart wallet\n   * @param params.signer - Local account used for signing transactions\n   * @param params.ownerIndex - Index of the signer in the wallet's owner list (defaults to 0)\n   * @returns SmartWallet instance\n   */ getWallet(params) {\n        const { walletAddress, signer, ownerIndex } = params;\n        return new DefaultSmartWallet([\n            signer.address\n        ], signer, this.chainManager, //   this.lendProvider,\n        walletAddress, ownerIndex);\n    }\n    /**\n   * Fund the wallet via a faucet\n   * @description Funds the current wallet via a faucet. Can only work if a selected chain is supported by a faucet and is a test network.\n   * @param chainId - Chain ID\n   * @returns Promise resolving to the transaction hash\n   */ fundViaFaucet() {}\n};\n// src/wallet/WalletProvider.ts\nvar WalletProvider = class {\n    constructor(embeddedWalletProvider, smartWalletProvider){\n        this.embeddedWalletProvider = embeddedWalletProvider;\n        this.smartWalletProvider = smartWalletProvider;\n    }\n    /**\n   * Create a new embedded wallet\n   * @description Creates only an embedded wallet using the configured embedded wallet provider.\n   * @returns Promise resolving to the created embedded wallet instance\n   */ async createEmbeddedWallet() {\n        return this.embeddedWalletProvider.createWallet();\n    }\n    /**\n   * Create a new smart wallet\n   * @description Creates only a smart wallet using the configured smart wallet provider.\n   * This is useful when you already have a signer and want to create a smart wallet without\n   * creating an embedded wallet. You must provide your own signer and owners array.\n   * @param params - Smart wallet creation parameters\n   * @param params.owners - Array of owners for the smart wallet (addresses or WebAuthn public keys)\n   * @param params.signer - Local account used for signing transactions\n   * @param params.nonce - Optional nonce for smart wallet address generation (defaults to 0)\n   * @returns Promise resolving to the created smart wallet instance\n   */ async createSmartWallet(params) {\n        const { owners, signer, nonce } = params;\n        return this.smartWalletProvider.createWallet({\n            owners,\n            signer,\n            nonce\n        });\n    }\n    /**\n   * Create a new smart wallet with embedded wallet as signer\n   * @description Creates both an embedded wallet and a smart wallet, with the embedded wallet\n   * automatically added as one of the owners/signers of the smart wallet.\n   * @param params - Optional wallet creation parameters\n   * @param params.owners - Optional array of additional owners for the smart wallet. The embedded wallet will be added to this array at the specified index.\n   * @param params.embeddedWalletIndex - Optional index where the embedded wallet should be inserted in the owners array. If not specified, embedded wallet is added to the end of the array.\n   * @param params.nonce - Optional nonce for smart wallet address generation (defaults to 0)\n   * @returns Promise resolving to the created smart wallet instance\n   */ async createWalletWithEmbeddedSigner(params) {\n        const { owners: ownersParam, embeddedWalletIndex, nonce } = params || {};\n        const embeddedWallet = await this.embeddedWalletProvider.createWallet();\n        const account = await embeddedWallet.account();\n        let owners;\n        if (ownersParam) {\n            owners = [\n                ...ownersParam\n            ];\n            const insertIndex = embeddedWalletIndex ?? owners.length;\n            owners.splice(insertIndex, 0, embeddedWallet.address);\n        } else {\n            owners = [\n                embeddedWallet.address\n            ];\n        }\n        return this.smartWalletProvider.createWallet({\n            owners,\n            signer: account,\n            nonce\n        });\n    }\n    /**\n   * Get an existing smart wallet using embedded wallet as signer\n   * @description Retrieves an embedded wallet by walletId and uses it as the signer to get\n   * the corresponding smart wallet. This is useful when you have\n   * an embedded wallet ID and want to access the associated smart wallet functionality.\n   * @dev If neither walletAddress nor deploymentOwners is provided,\n   * defaults to using the embedded wallet as the single owner.\n   * @param params - Wallet retrieval parameters\n   * @param params.walletId - ID of the embedded wallet to use as signer\n   * @param params.deploymentOwners - Optional array of original deployment owners for smart wallet address calculation. If not provided and walletAddress is also not provided, defaults to using the embedded wallet as single owner.\n   * @param params.signerOwnerIndex - Current index of the signer in the smart wallet's current owners array (used for transaction signing). Defaults to 0 if not specified. This may differ from the original deployment index if owners have been modified.\n   * @param params.walletAddress - Optional explicit smart wallet address (skips address calculation)\n   * @param params.nonce - Optional nonce used during smart wallet creation\n   * @returns Promise resolving to the smart wallet instance with embedded wallet as signer\n   * @throws Error if embedded wallet is not found\n   */ async getSmartWalletWithEmbeddedSigner(params) {\n        const { walletId, deploymentOwners, walletAddress } = params;\n        const embeddedWallet = await this.embeddedWalletProvider.getWallet({\n            walletId\n        });\n        if (!embeddedWallet) {\n            throw new Error(\"Embedded wallet not found\");\n        }\n        const account = await embeddedWallet.account();\n        const finalDeploymentOwners = deploymentOwners || (walletAddress ? void 0 : [\n            embeddedWallet.address\n        ]);\n        return this.getSmartWallet({\n            signer: account,\n            ...params,\n            deploymentOwners: finalDeploymentOwners\n        });\n    }\n    /**\n   * Get an existing embedded wallet\n   * @description Retrieves an embedded wallet by walletId. This is useful when you have an embedded wallet ID and\n   * want to access the associated embedded wallet functionality.\n   * @param params - Wallet retrieval parameters\n   * @param params.walletId - ID of the embedded wallet to retrieve\n   * @returns Promise resolving to the embedded wallet instance\n   */ async getEmbeddedWallet(params) {\n        const { walletId } = params;\n        return this.embeddedWalletProvider.getWallet({\n            walletId\n        });\n    }\n    /**\n   * Get an existing smart wallet with a provided signer\n   * @description Retrieves a smart wallet using a directly provided signer. This is useful when\n   * you already have a LocalAccount signer and want to access an existing smart wallet without\n   * going through the embedded wallet provider. Use this instead of getSmartWalletWithEmbeddedSigner\n   * when you have direct control over the signer.\n   * @param signer - Local account to use for signing transactions on the smart wallet\n   * @param getWalletParams - Wallet retrieval parameters\n   * @param getWalletParams.deploymentOwners - Array of original deployment owners for smart wallet address calculation. Required if walletAddress not provided. Must match the exact owners array used during wallet deployment.\n   * @param getWalletParams.signerOwnerIndex - Current index of the signer in the smart wallet's current owners array (used for transaction signing). Defaults to 0 if not specified. This may differ from the original deployment index if owners have been modified.\n   * @param getWalletParams.walletAddress - Optional explicit smart wallet address (skips address calculation)\n   * @param getWalletParams.nonce - Optional nonce used during smart wallet creation\n   * @returns Promise resolving to the smart wallet instance with the provided signer\n   * @throws Error if neither walletAddress nor deploymentOwners provided\n   */ async getSmartWallet(params) {\n        const { signer, deploymentOwners, signerOwnerIndex, walletAddress: walletAddressParam, nonce } = params;\n        if (!walletAddressParam && !deploymentOwners) {\n            try {\n                throw new Error(\"Either walletAddress or deploymentOwners array must be provided to locate the smart wallet\");\n            } catch (error) {\n                console.error(error);\n                throw new Error(\"Either walletAddress or deploymentOwners array must be provided to locate the smart wallet\");\n            }\n        }\n        const ownerIndex = signerOwnerIndex ?? 0;\n        const walletAddress = walletAddressParam || await this.smartWalletProvider.getWalletAddress({\n            // Safe to use ! since we validated above\n            owners: deploymentOwners,\n            nonce\n        });\n        return this.smartWalletProvider.getWallet({\n            walletAddress,\n            signer,\n            ownerIndex\n        });\n    }\n};\n// src/wallet/providers/PrivyEmbeddedWalletProvider.ts\n\n// src/wallet/PrivyWallet.ts\n\n\n\n// src/wallet/base/wallets/EmbeddedWallet.ts\nvar EmbeddedWallet = class {\n    /**\n   * Create an embedded wallet instance\n   * @param address - The wallet's Ethereum address\n   */ constructor(address, walletId){\n        this.address = address;\n        this.walletId = walletId;\n    }\n};\n// src/wallet/PrivyWallet.ts\nvar PrivyWallet = class extends EmbeddedWallet {\n    //   private lendProvider: LendProvider;\n    /**\n   * Create a new Privy wallet provider\n   * @param appId - Privy application ID\n   * @param appSecret - Privy application secret\n   * @param verbs - Verbs instance for accessing configured providers\n   */ constructor(privyClient, walletId, address, chainManager){\n        super(address, walletId);\n        this.privyClient = privyClient;\n        this.walletId = walletId;\n        this.chainManager = chainManager;\n    }\n    /**\n   * Create a LocalAccount from this Privy wallet\n   * @description Converts the Privy wallet into a viem-compatible LocalAccount that can sign\n   * messages and transactions. The returned account uses Privy's signing infrastructure\n   * under the hood while providing a standard viem interface.\n   * @returns Promise resolving to a LocalAccount configured for signing operations\n   * @throws Error if wallet retrieval fails or signing operations are not supported\n   */ async account() {\n        const account = await (0,_privy_io_server_auth_viem__WEBPACK_IMPORTED_MODULE_16__.createViemAccount)({\n            walletId: this.walletId,\n            address: this.address,\n            // TODO: Fix this type error\n            privy: this.privyClient\n        });\n        return account;\n    }\n    /**\n   * Create a WalletClient for this Privy wallet\n   * @description Creates a viem-compatible WalletClient configured with this wallet's account\n   * and the specified chain. The returned client can be used to send transactions and interact\n   * with smart contracts using Privy's signing infrastructure under the hood.\n   * @param chainId - The chain ID to create the wallet client for\n   * @returns Promise resolving to a WalletClient configured for the specified chain\n   * @throws Error if chain is not supported or wallet client creation fails\n   */ async walletClient(chainId) {\n        const account = await this.account();\n        return (0,viem__WEBPACK_IMPORTED_MODULE_17__.createWalletClient)({\n            account,\n            chain: this.chainManager.getChain(chainId),\n            transport: (0,viem__WEBPACK_IMPORTED_MODULE_2__.http)(this.chainManager.getRpcUrl(chainId))\n        });\n    }\n    // ⚠️  WARNING: TECH DEBT BELOW ⚠️\n    // =====================================\n    // The methods below this comment are legacy tech debt from the POC\n    // and will most likely be REMOVED in a future refactor.\n    //\n    // DO NOT rely on these methods in production code!\n    // DO NOT extend or modify these methods!\n    //\n    // If you need this functionality, please discuss with the team\n    // before using or building upon these methods.\n    // =====================================\n    /**\n   * Lend assets to a lending market\n   * @description Lends assets using the configured lending provider with human-readable amounts\n   * @param amount - Human-readable amount to lend (e.g. 1.5)\n   * @param asset - Asset symbol (e.g. 'usdc') or token address\n   * @param marketId - Optional specific market ID or vault name\n   * @param options - Optional lending configuration\n   * @returns Promise resolving to lending transaction details\n   * @throws Error if no lending provider is configured\n   */ //   async lend(\n    //     amount: number,\n    //     asset: AssetIdentifier,\n    //     marketId?: string,\n    //     options?: LendOptions\n    //   ): Promise<LendTransaction> {\n    //     // Parse human-readable inputs\n    //     // TODO: Get actual chain ID from wallet context, for now using Unichain\n    //     const { amount: parsedAmount, asset: resolvedAsset } = parseLendParams(\n    //       amount,\n    //       asset,\n    //       unichain.id\n    //     );\n    //     // Set receiver to wallet address if not specified\n    //     const lendOptions: LendOptions = {\n    //       ...options,\n    //       receiver: options?.receiver || this.address,\n    //     };\n    //     const result = await this.lendProvider.deposit(\n    //       resolvedAsset.address,\n    //       parsedAmount,\n    //       marketId,\n    //       lendOptions\n    //     );\n    //     return result;\n    //   }\n    /**\n   * Sign a transaction without sending it\n   * @description Signs a transaction using the configured wallet provider but doesn't send it\n   * @param transactionData - Transaction data to sign\n   * @returns Promise resolving to signed transaction\n   * @throws Error if wallet is not initialized or no wallet provider is configured\n   */ async sign(transactionData) {\n        return await this.signOnly(transactionData);\n    }\n    /**\n   * Sign a transaction without sending it\n   * @description Signs a transaction using Privy's wallet API but doesn't send it\n   * @param walletId - Wallet ID to use for signing\n   * @param transactionData - Transaction data to sign\n   * @returns Promise resolving to signed transaction\n   * @throws Error if transaction signing fails\n   */ async signOnly(transactionData) {\n        try {\n            const privyWallet = await this.privyClient.walletApi.getWallet({\n                id: this.walletId\n            });\n            const publicClient = this.chainManager.getPublicClient(viem_chains__WEBPACK_IMPORTED_MODULE_5__.unichain.id);\n            const gasLimit = await publicClient.estimateGas({\n                account: privyWallet.address,\n                to: transactionData.to,\n                data: transactionData.data,\n                value: BigInt(transactionData.value)\n            });\n            const feeData = await publicClient.estimateFeesPerGas();\n            const nonce = await publicClient.getTransactionCount({\n                address: privyWallet.address,\n                blockTag: \"pending\"\n            });\n            const txParams = {\n                to: transactionData.to,\n                data: transactionData.data,\n                value: transactionData.value,\n                chainId: 130,\n                // Unichain\n                type: 2,\n                // EIP-1559\n                gasLimit: `0x${gasLimit.toString(16)}`,\n                maxFeePerGas: `0x${(feeData.maxFeePerGas || BigInt(1e9)).toString(16)}`,\n                // fallback to 1 gwei\n                maxPriorityFeePerGas: `0x${(feeData.maxPriorityFeePerGas || BigInt(1e8)).toString(16)}`,\n                // fallback to 0.1 gwei\n                nonce: `0x${nonce.toString(16)}`\n            };\n            console.log(`[PRIVY_PROVIDER] Complete tx params - Type: ${txParams.type}, Nonce: ${nonce}, Limit: ${gasLimit}, MaxFee: ${feeData.maxFeePerGas || \"fallback\"}, Priority: ${feeData.maxPriorityFeePerGas || \"fallback\"}`);\n            const response = await this.privyClient.walletApi.ethereum.signTransaction({\n                walletId: this.walletId,\n                transaction: txParams\n            });\n            return response.signedTransaction;\n        } catch (error) {\n            throw new Error(`Failed to sign transaction for wallet ${this.walletId}: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n        }\n    }\n    /**\n   * Send a signed transaction\n   * @description Sends a pre-signed transaction to the network\n   * @param signedTransaction - Signed transaction to send\n   * @param publicClient - Viem public client to send the transaction\n   * @returns Promise resolving to transaction hash\n   */ async send(signedTransaction, publicClient) {\n        try {\n            const hash = await publicClient.sendRawTransaction({\n                serializedTransaction: signedTransaction\n            });\n            return hash;\n        } catch (error) {\n            throw new Error(`Failed to send transaction: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n        }\n    }\n};\n// src/wallet/base/providers/EmbeddedWalletProvider.ts\nvar EmbeddedWalletProvider = class {\n};\n// src/wallet/providers/PrivyEmbeddedWalletProvider.ts\nvar PrivyEmbeddedWalletProvider = class extends EmbeddedWalletProvider {\n    //   private lendProvider: LendProvider;\n    /**\n   * Create a new Privy wallet provider\n   * @param privyClient - Privy client instance\n   */ constructor(privyClient, chainManager){\n        super();\n        this.privy = privyClient;\n        this.chainManager = chainManager;\n    }\n    /**\n   * Create new wallet via Privy\n   * @description Creates a new wallet using Privy's wallet API\n   * @returns Promise resolving to new wallet instance\n   * @throws Error if wallet creation fails\n   */ async createWallet() {\n        try {\n            const wallet = await this.privy.walletApi.createWallet({\n                chainType: \"ethereum\"\n            });\n            const walletInstance = new PrivyWallet(this.privy, wallet.id, (0,viem__WEBPACK_IMPORTED_MODULE_18__.getAddress)(wallet.address), this.chainManager);\n            return walletInstance;\n        } catch (error) {\n            console.error(\"Failed to create wallet: \", error);\n            throw new Error(`Failed to create wallet: ${error}`);\n        }\n    }\n    /**\n   * Get wallet by wallet ID via Privy\n   * @description Retrieves wallet information from Privy service\n   * @param params - Parameters containing walletId\n   * @returns Promise resolving to wallet\n   */ async getWallet(params) {\n        try {\n            const wallet = await this.privy.walletApi.getWallet({\n                id: params.walletId\n            });\n            const walletInstance = new PrivyWallet(this.privy, wallet.id, (0,viem__WEBPACK_IMPORTED_MODULE_18__.getAddress)(wallet.address), this.chainManager);\n            return walletInstance;\n        } catch  {\n            throw new Error(`Failed to get wallet with id: ${params.walletId}`);\n        }\n    }\n    /**\n   * Get all wallets via Privy\n   * @description Retrieves all wallets from Privy service with optional filtering\n   * @param options - Optional parameters for filtering and pagination\n   * @returns Promise resolving to array of wallets\n   */ async getAllWallets(options) {\n        try {\n            const response = await this.privy.walletApi.getWallets({\n                limit: options?.limit,\n                cursor: options?.cursor\n            });\n            return response.data.map((wallet)=>{\n                const walletInstance = new PrivyWallet(this.privy, wallet.id, (0,viem__WEBPACK_IMPORTED_MODULE_18__.getAddress)(wallet.address), this.chainManager);\n                return walletInstance;\n            });\n        } catch  {\n            throw new Error(\"Failed to retrieve wallets\");\n        }\n    }\n};\n// src/index.ts\n\nvar MyceliumSDK = class {\n    constructor(config){\n        this._chainManager = new ChainManager(config.chains || [\n            {\n                chainId: viem_chains__WEBPACK_IMPORTED_MODULE_5__.unichain.id,\n                rpcUrl: viem_chains__WEBPACK_IMPORTED_MODULE_5__.unichain.rpcUrls.default.http[0]\n            }\n        ]);\n        this.wallet = this.createWalletNamespace(config.walletsConfig);\n    }\n    /**\n   * Get the chain manager instance\n   * @returns ChainManager instance for multi-chain operations\n   */ get chainManager() {\n        return this._chainManager;\n    }\n    /**\n   * Create the wallet provider instance\n   * @param config - Wallet configuration\n   * @returns WalletProvider instance\n   */ createWalletProvider(config) {\n        if (config.embeddedWalletConfig.provider.type === \"privy\") {\n            const privyClient = new _privy_io_server_auth__WEBPACK_IMPORTED_MODULE_19__.PrivyClient(config.embeddedWalletConfig.provider.providerConfig.appId, config.embeddedWalletConfig.provider.providerConfig.appSecret);\n            this.embeddedWalletProvider = new PrivyEmbeddedWalletProvider(// config.embeddedWalletConfig.provider.privyClient,\n            privyClient, this._chainManager);\n        } else {\n            throw new Error(`Unsupported embedded wallet provider: ${config.embeddedWalletConfig.provider.type}`);\n        }\n        if (!config.smartWalletConfig || config.smartWalletConfig.provider.type === \"default\") {\n            this.smartWalletProvider = new DefaultSmartWalletProvider(this.chainManager);\n        } else {\n            throw new Error(`Unsupported smart wallet provider: ${config.smartWalletConfig.provider.type}`);\n        }\n        const walletProvider = new WalletProvider(this.embeddedWalletProvider, this.smartWalletProvider);\n        return walletProvider;\n    }\n    /**\n   * Create the wallet namespace instance\n   * @param config - Wallet configuration\n   * @returns WalletNamespace instance\n   */ createWalletNamespace(config) {\n        const walletProvider = this.createWalletProvider(config);\n        return new WalletNamespace(walletProvider);\n    }\n};\nvar index_default = MyceliumSDK;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cUJBQXFCLFFBQTRDO1FBQ3ZFLElBQUksT0FBTyxxQkFBcUIsU0FBUyxTQUFTLFNBQVM7WUFDekQsTUFBTSxjQUFjLElBQUksK0RBQVcsQ0FDakMsT0FBTyxxQkFBcUIsU0FBUyxlQUFlLE9BQ3BELE9BQU8scUJBQXFCLFNBQVMsZUFBZTtZQUd0RCxLQUFLLHlCQUF5QixJQUFJO1lBRWhDLGFBQ0EsS0FBSztRQUdULE9BQU87WUFDTCxNQUFNLElBQUksTUFDUix5Q0FBeUMsT0FBTyxxQkFBcUIsU0FBUyxJQUFJO1FBRXRGO1FBRUEsSUFDRSxDQUFDLE9BQU8scUJBQ1IsT0FBTyxrQkFBa0IsU0FBUyxTQUFTLFdBQzNDO1lBQ0EsS0FBSyxzQkFBc0IsSUFBSSwyQkFDN0IsS0FBSztRQUdULE9BQU87WUFDTCxNQUFNLElBQUksTUFDUixzQ0FBc0MsT0FBTyxrQkFBa0IsU0FBUyxJQUFJO1FBRWhGO1FBRUEsTUFBTSxpQkFBaUIsSUFBSSxlQUN6QixLQUFLLHdCQUNMLEtBQUs7UUFHUCxPQUFPO0lBQ1Q7SUFBQTs7OztHQUFBLEdBT1Esc0JBQXNCLFFBQTRDO1FBQ3hFLE1BQU0saUJBQWlCLEtBQUsscUJBQXFCLE1BQU07UUFDdkQsT0FBTyxJQUFJLGdCQUFnQixjQUFjO0lBQzNDO0FBQ0Y7QUFFQSxJQUFPLGdCQUFRIiwic291cmNlcyI6WyIvVXNlcnMvYWRtaW4vRG9jdW1lbnRzL3Byb2plY3RzL215Y2VsaXVtLXNkay9wYWNrYWdlcy9zcmMvdG9vbHMvQ2hhaW5NYW5hZ2VyLnRzIiwiL1VzZXJzL2FkbWluL0RvY3VtZW50cy9wcm9qZWN0cy9teWNlbGl1bS1zZGsvcGFja2FnZXMvc3JjL3V0aWxzL2NoYWlucy50cyIsIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL3NyYy93YWxsZXQvYmFzZS9wcm92aWRlcnMvU21hcnRXYWxsZXRQcm92aWRlci50cyIsIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL3NyYy93YWxsZXQvV2FsbGV0TmFtZXNwYWNlLnRzIiwiL1VzZXJzL2FkbWluL0RvY3VtZW50cy9wcm9qZWN0cy9teWNlbGl1bS1zZGsvcGFja2FnZXMvc3JjL2luZGV4LnRzIiwiL1VzZXJzL2FkbWluL0RvY3VtZW50cy9wcm9qZWN0cy9teWNlbGl1bS1zZGsvcGFja2FnZXMvc3JjL3dhbGxldC9wcm92aWRlcnMvRGVmYXVsdFNtYXJ0V2FsbGV0UHJvdmlkZXIudHMiLCIvVXNlcnMvYWRtaW4vRG9jdW1lbnRzL3Byb2plY3RzL215Y2VsaXVtLXNkay9wYWNrYWdlcy9zcmMvYWJpcy9zbWFydFdhbGxldEZhY3RvcnkudHMiLCIvVXNlcnMvYWRtaW4vRG9jdW1lbnRzL3Byb2plY3RzL215Y2VsaXVtLXNkay9wYWNrYWdlcy9zcmMvY29uc3RhbnRzL2FkZHJlc3Nlcy50cyIsIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL3NyYy93YWxsZXQvRGVmYXVsdFNtYXJ0V2FsbGV0LnRzIiwiL1VzZXJzL2FkbWluL0RvY3VtZW50cy9wcm9qZWN0cy9teWNlbGl1bS1zZGsvcGFja2FnZXMvc3JjL3Rvb2xzL1Rva2VuQmFsYW5jZS50cyIsIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL3NyYy9jb25zdGFudHMvdG9rZW5zLnRzIiwiL1VzZXJzL2FkbWluL0RvY3VtZW50cy9wcm9qZWN0cy9teWNlbGl1bS1zZGsvcGFja2FnZXMvc3JjL3V0aWxzL3Rva2Vucy50cyIsIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL3NyYy91dGlscy9hc3NldHMudHMiLCIvVXNlcnMvYWRtaW4vRG9jdW1lbnRzL3Byb2plY3RzL215Y2VsaXVtLXNkay9wYWNrYWdlcy9zcmMvd2FsbGV0L2Jhc2Uvd2FsbGV0cy9TbWFydFdhbGxldC50cyIsIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL3NyYy93YWxsZXQvV2FsbGV0UHJvdmlkZXIudHMiLCIvVXNlcnMvYWRtaW4vRG9jdW1lbnRzL3Byb2plY3RzL215Y2VsaXVtLXNkay9wYWNrYWdlcy9zcmMvd2FsbGV0L3Byb3ZpZGVycy9Qcml2eUVtYmVkZGVkV2FsbGV0UHJvdmlkZXIudHMiLCIvVXNlcnMvYWRtaW4vRG9jdW1lbnRzL3Byb2plY3RzL215Y2VsaXVtLXNkay9wYWNrYWdlcy9zcmMvd2FsbGV0L1ByaXZ5V2FsbGV0LnRzIiwiL1VzZXJzL2FkbWluL0RvY3VtZW50cy9wcm9qZWN0cy9teWNlbGl1bS1zZGsvcGFja2FnZXMvc3JjL3dhbGxldC9iYXNlL3dhbGxldHMvRW1iZWRkZWRXYWxsZXQudHMiLCIvVXNlcnMvYWRtaW4vRG9jdW1lbnRzL3Byb2plY3RzL215Y2VsaXVtLXNkay9wYWNrYWdlcy9zcmMvd2FsbGV0L2Jhc2UvcHJvdmlkZXJzL0VtYmVkZGVkV2FsbGV0UHJvdmlkZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHlwZSBDaGFpbiwgY3JlYXRlUHVibGljQ2xpZW50LCBodHRwLCB0eXBlIFB1YmxpY0NsaWVudCB9IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgdHlwZSB7IEJ1bmRsZXJDbGllbnQsIFNtYXJ0QWNjb3VudCB9IGZyb20gXCJ2aWVtL2FjY291bnQtYWJzdHJhY3Rpb25cIjtcbmltcG9ydCB7IGNyZWF0ZUJ1bmRsZXJDbGllbnQgfSBmcm9tIFwidmllbS9hY2NvdW50LWFic3RyYWN0aW9uXCI7XG5cbmltcG9ydCB0eXBlIHsgU1VQUE9SVEVEX0NIQUlOX0lEUyB9IGZyb20gXCJAL2NvbnN0YW50cy9jaGFpbnNcIjtcbmltcG9ydCB0eXBlIHsgQ2hhaW5Db25maWcgfSBmcm9tIFwiQC90eXBlcy9jaGFpblwiO1xuaW1wb3J0IHsgY2hhaW5CeUlkIH0gZnJvbSBcIkAvdXRpbHMvY2hhaW5zXCI7XG5cbi8qKlxuICogQ2hhaW4gTWFuYWdlciBTZXJ2aWNlXG4gKiBAZGVzY3JpcHRpb24gTWFuYWdlcyBwdWJsaWMgY2xpZW50cyBhbmQgY2hhaW4gaW5mcmFzdHJ1Y3R1cmUgZm9yIHRoZSBWZXJicyBTREsuXG4gKiBQcm92aWRlcyB1dGlsaXRpZXMgZm9yIGFjY2Vzc2luZyBSUEMgYW5kIGJ1bmRsZXIgVVJMcywgYW5kIGNyZWF0aW5nIGNsaWVudHMgZm9yIHN1cHBvcnRlZCBjaGFpbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGFpbk1hbmFnZXIge1xuICAvKiogTWFwIG9mIGNoYWluIElEcyB0byB0aGVpciBjb3JyZXNwb25kaW5nIHB1YmxpYyBjbGllbnRzICovXG4gIHByaXZhdGUgcHVibGljQ2xpZW50czogTWFwPFxuICAgICh0eXBlb2YgU1VQUE9SVEVEX0NIQUlOX0lEUylbbnVtYmVyXSxcbiAgICBQdWJsaWNDbGllbnRcbiAgPjtcbiAgLyoqIENvbmZpZ3VyYXRpb24gZm9yIGVhY2ggc3VwcG9ydGVkIGNoYWluICovXG4gIHByaXZhdGUgY2hhaW5Db25maWdzOiBDaGFpbkNvbmZpZ1tdO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBDaGFpbk1hbmFnZXIgd2l0aCBjaGFpbiBjb25maWd1cmF0aW9uc1xuICAgKiBAcGFyYW0gY2hhaW5zIC0gQXJyYXkgb2YgY2hhaW4gY29uZmlndXJhdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNoYWluczogQ2hhaW5Db25maWdbXSkge1xuICAgIHRoaXMuY2hhaW5Db25maWdzID0gY2hhaW5zO1xuICAgIHRoaXMucHVibGljQ2xpZW50cyA9IHRoaXMuY3JlYXRlUHVibGljQ2xpZW50cyhjaGFpbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwdWJsaWMgY2xpZW50IGZvciBhIHNwZWNpZmljIGNoYWluXG4gICAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIGNoYWluIElEIHRvIHJldHJpZXZlIHRoZSBwdWJsaWMgY2xpZW50IGZvclxuICAgKiBAcmV0dXJucyBQdWJsaWNDbGllbnQgaW5zdGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgY2hhaW5cbiAgICogQHRocm93cyBFcnJvciBpZiBubyBjbGllbnQgaXMgY29uZmlndXJlZCBmb3IgdGhlIGNoYWluIElEXG4gICAqL1xuICBnZXRQdWJsaWNDbGllbnQoY2hhaW5JZDogKHR5cGVvZiBTVVBQT1JURURfQ0hBSU5fSURTKVtudW1iZXJdKTogUHVibGljQ2xpZW50IHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLnB1YmxpY0NsaWVudHMuZ2V0KGNoYWluSWQpO1xuICAgIGlmICghY2xpZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHB1YmxpYyBjbGllbnQgY29uZmlndXJlZCBmb3IgY2hhaW4gSUQ6ICR7Y2hhaW5JZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYnVuZGxlciBjbGllbnQgZm9yIGEgc3BlY2lmaWMgY2hhaW5cbiAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgY2hhaW4gSUQgdG8gcmV0cmlldmUgdGhlIGJ1bmRsZXIgY2xpZW50IGZvclxuICAgKiBAcGFyYW0gYWNjb3VudCAtIFNtYXJ0QWNjb3VudCB0byB1c2Ugd2l0aCB0aGUgYnVuZGxlciBjbGllbnRcbiAgICogQHJldHVybnMgQnVuZGxlckNsaWVudCBpbnN0YW5jZSBmb3IgdGhlIHNwZWNpZmllZCBjaGFpblxuICAgKiBAdGhyb3dzIEVycm9yIGlmIG5vIGJ1bmRsZXIgVVJMIGlzIGNvbmZpZ3VyZWQgZm9yIHRoZSBjaGFpbiBJRFxuICAgKi9cbiAgZ2V0QnVuZGxlckNsaWVudChcbiAgICBjaGFpbklkOiAodHlwZW9mIFNVUFBPUlRFRF9DSEFJTl9JRFMpW251bWJlcl0sXG4gICAgYWNjb3VudDogU21hcnRBY2NvdW50XG4gICk6IEJ1bmRsZXJDbGllbnQge1xuICAgIGNvbnN0IGJ1bmRsZXJVcmwgPSB0aGlzLmdldEJ1bmRsZXJVcmwoY2hhaW5JZCk7XG4gICAgaWYgKCFidW5kbGVyVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGJ1bmRsZXIgVVJMIGNvbmZpZ3VyZWQgZm9yIGNoYWluIElEOiAke2NoYWluSWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZVB1YmxpY0NsaWVudCh7XG4gICAgICBjaGFpbjogdGhpcy5nZXRDaGFpbihjaGFpbklkKSxcbiAgICAgIHRyYW5zcG9ydDogaHR0cChidW5kbGVyVXJsKSxcbiAgICB9KTtcbiAgICByZXR1cm4gY3JlYXRlQnVuZGxlckNsaWVudCh7XG4gICAgICBhY2NvdW50LFxuICAgICAgY2xpZW50LFxuICAgICAgdHJhbnNwb3J0OiBodHRwKGJ1bmRsZXJVcmwpLFxuICAgICAgY2hhaW46IHRoaXMuZ2V0Q2hhaW4oY2hhaW5JZCksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IFJQQyBVUkwgZm9yIGEgc3BlY2lmaWMgY2hhaW5cbiAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgY2hhaW4gSUQgdG8gcmV0cmlldmUgdGhlIFJQQyBVUkwgZm9yXG4gICAqIEByZXR1cm5zIFJQQyBVUkwgYXMgYSBzdHJpbmdcbiAgICogQHRocm93cyBFcnJvciBpZiBubyBjaGFpbiBjb25maWcgaXMgZm91bmQgZm9yIHRoZSBjaGFpbiBJRFxuICAgKi9cbiAgZ2V0UnBjVXJsKGNoYWluSWQ6ICh0eXBlb2YgU1VQUE9SVEVEX0NIQUlOX0lEUylbbnVtYmVyXSk6IHN0cmluZyB7XG4gICAgY29uc3QgY2hhaW5Db25maWcgPSB0aGlzLmNoYWluQ29uZmlncy5maW5kKChjKSA9PiBjLmNoYWluSWQgPT09IGNoYWluSWQpO1xuICAgIGlmICghY2hhaW5Db25maWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY2hhaW4gY29uZmlnIGZvdW5kIGZvciBjaGFpbiBJRDogJHtjaGFpbklkfWApO1xuICAgIH1cbiAgICByZXR1cm4gY2hhaW5Db25maWcucnBjVXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBidW5kbGVyIFVSTCBmb3IgYSBzcGVjaWZpYyBjaGFpblxuICAgKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBjaGFpbiBJRCB0byByZXRyaWV2ZSB0aGUgYnVuZGxlciBVUkwgZm9yXG4gICAqIEByZXR1cm5zIEJ1bmRsZXIgVVJMIGFzIGEgc3RyaW5nIG9yIHVuZGVmaW5lZCBpZiBub3QgY29uZmlndXJlZFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIG5vIGNoYWluIGNvbmZpZyBpcyBmb3VuZCBmb3IgdGhlIGNoYWluIElEXG4gICAqL1xuICBnZXRCdW5kbGVyVXJsKFxuICAgIGNoYWluSWQ6ICh0eXBlb2YgU1VQUE9SVEVEX0NIQUlOX0lEUylbbnVtYmVyXVxuICApOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGNoYWluQ29uZmlnID0gdGhpcy5jaGFpbkNvbmZpZ3MuZmluZCgoYykgPT4gYy5jaGFpbklkID09PSBjaGFpbklkKTtcbiAgICBpZiAoIWNoYWluQ29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNoYWluIGNvbmZpZyBmb3VuZCBmb3IgY2hhaW4gSUQ6ICR7Y2hhaW5JZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYWluQ29uZmlnLmJ1bmRsZXJVcmw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNoYWluIGluZm9ybWF0aW9uIGZvciBhIHNwZWNpZmljIGNoYWluIElEXG4gICAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIGNoYWluIElEIHRvIHJldHJpZXZlIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcmV0dXJucyBDaGFpbiBvYmplY3QgY29udGFpbmluZyBjaGFpbiBkZXRhaWxzXG4gICAqL1xuICBnZXRDaGFpbihjaGFpbklkOiAodHlwZW9mIFNVUFBPUlRFRF9DSEFJTl9JRFMpW251bWJlcl0pOiBDaGFpbiB7XG4gICAgY29uc3QgY2hhaW4gPSBjaGFpbkJ5SWRbY2hhaW5JZF07XG4gICAgaWYgKCFjaGFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGFpbiBub3QgZm91bmQgZm9yIElEOiAke2NoYWluSWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFpbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHN1cHBvcnRlZCBjaGFpbiBJRHNcbiAgICogQHJldHVybnMgQXJyYXkgb2Ygc3VwcG9ydGVkIGNoYWluIElEc1xuICAgKi9cbiAgZ2V0U3VwcG9ydGVkQ2hhaW5zKCkge1xuICAgIHJldHVybiB0aGlzLmNoYWluQ29uZmlncy5tYXAoKGMpID0+IGMuY2hhaW5JZCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHB1YmxpYyBjbGllbnRzIGZvciBhbGwgY29uZmlndXJlZCBjaGFpbnNcbiAgICogQHBhcmFtIGNoYWlucyAtIEFycmF5IG9mIGNoYWluIGNvbmZpZ3VyYXRpb25zXG4gICAqIEByZXR1cm5zIE1hcCBvZiBjaGFpbiBJRHMgdG8gdGhlaXIgY29ycmVzcG9uZGluZyBwdWJsaWMgY2xpZW50c1xuICAgKiBAdGhyb3dzIEVycm9yIGlmIGEgY2hhaW4gaXMgbm90IGZvdW5kIG9yIGFscmVhZHkgY29uZmlndXJlZFxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVQdWJsaWNDbGllbnRzKFxuICAgIGNoYWluczogQ2hhaW5Db25maWdbXVxuICApOiBNYXA8KHR5cGVvZiBTVVBQT1JURURfQ0hBSU5fSURTKVtudW1iZXJdLCBQdWJsaWNDbGllbnQ+IHtcbiAgICBjb25zdCBjbGllbnRzID0gbmV3IE1hcDxcbiAgICAgICh0eXBlb2YgU1VQUE9SVEVEX0NIQUlOX0lEUylbbnVtYmVyXSxcbiAgICAgIFB1YmxpY0NsaWVudFxuICAgID4oKTtcblxuICAgIGZvciAoY29uc3QgY2hhaW5Db25maWcgb2YgY2hhaW5zKSB7XG4gICAgICBjb25zdCBjaGFpbiA9IGNoYWluQnlJZFtjaGFpbkNvbmZpZy5jaGFpbklkXTtcbiAgICAgIGlmICghY2hhaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGFpbiBub3QgZm91bmQgZm9yIElEOiAke2NoYWluQ29uZmlnLmNoYWluSWR9YCk7XG4gICAgICB9XG4gICAgICBpZiAoY2xpZW50cy5oYXMoY2hhaW5Db25maWcuY2hhaW5JZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQdWJsaWMgY2xpZW50IGFscmVhZHkgY29uZmlndXJlZCBmb3IgY2hhaW4gSUQ6ICR7Y2hhaW5Db25maWcuY2hhaW5JZH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVQdWJsaWNDbGllbnQoe1xuICAgICAgICBjaGFpbixcbiAgICAgICAgdHJhbnNwb3J0OiBodHRwKGNoYWluQ29uZmlnLnJwY1VybCksXG4gICAgICB9KTtcblxuICAgICAgY2xpZW50cy5zZXQoY2hhaW5Db25maWcuY2hhaW5JZCwgY2xpZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpZW50cztcbiAgfVxufVxuIiwiaW1wb3J0IHsgdHlwZSBDaGFpbiB9IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgKiBhcyB2aWVtQ2hhaW5zIGZyb20gXCJ2aWVtL2NoYWluc1wiO1xuXG4vKiogUnVudGltZSBtYXA6IGNoYWluIElEIC0+IENoYWluICovXG5leHBvcnQgY29uc3QgY2hhaW5CeUlkOiBSZWNvcmQ8bnVtYmVyLCBDaGFpbj4gPSBPYmplY3QudmFsdWVzKFxuICB2aWVtQ2hhaW5zXG4pLnJlZHVjZShcbiAgKGFjYywgbWF5YmVDaGFpbikgPT4ge1xuICAgIC8vIHZpZW0vY2hhaW5zIGV4cG9ydHMgYm90aCBjaGFpbiBvYmplY3RzIGFuZCBoZWxwZXJzOyBwaWNrIG9ubHkgcmVhbCBDaGFpbiBvYmplY3RzXG4gICAgaWYgKFxuICAgICAgbWF5YmVDaGFpbiAmJlxuICAgICAgdHlwZW9mIG1heWJlQ2hhaW4gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgIFwiaWRcIiBpbiBtYXliZUNoYWluICYmXG4gICAgICB0eXBlb2YgKG1heWJlQ2hhaW4gYXMgYW55KS5pZCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgXCJuYW1lXCIgaW4gbWF5YmVDaGFpblxuICAgICkge1xuICAgICAgY29uc3QgY2hhaW4gPSBtYXliZUNoYWluIGFzIENoYWluO1xuICAgICAgYWNjW2NoYWluLmlkXSA9IGNoYWluO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LFxuICB7fSBhcyBSZWNvcmQ8bnVtYmVyLCBDaGFpbj5cbik7XG4iLCJpbXBvcnQgdHlwZSB7IEFkZHJlc3MsIExvY2FsQWNjb3VudCB9IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgdHlwZSB7IFdlYkF1dGhuQWNjb3VudCB9IGZyb20gXCJ2aWVtL2FjY291bnQtYWJzdHJhY3Rpb25cIjtcblxuaW1wb3J0IHR5cGUgeyBTbWFydFdhbGxldCB9IGZyb20gXCJAL3dhbGxldC9iYXNlL3dhbGxldHMvU21hcnRXYWxsZXQuanNcIjtcblxuLyoqXG4gKiBCYXNlIHNtYXJ0IHdhbGxldCBwcm92aWRlciBpbnRlcmZhY2VcbiAqIEBkZXNjcmlwdGlvbiBBYnN0cmFjdCBpbnRlcmZhY2UgZm9yIHNtYXJ0IHdhbGxldCBwcm92aWRlcnMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTbWFydFdhbGxldFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzbWFydCB3YWxsZXQgaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBuZXcgc21hcnQgd2FsbGV0IHRoYXQgd2lsbCBiZSBkZXBsb3llZCBvbiBmaXJzdCB0cmFuc2FjdGlvbi5cbiAgICogVGhlIHdhbGxldCBhZGRyZXNzIGlzIGRldGVybWluaXN0aWNhbGx5IGNhbGN1bGF0ZWQgZnJvbSBvd25lcnMgYW5kIG5vbmNlLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gV2FsbGV0IGNyZWF0aW9uIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHBhcmFtcy5vd25lcnMgLSBBcnJheSBvZiB3YWxsZXQgb3duZXJzIChhZGRyZXNzZXMgb3IgV2ViQXV0aG4gcHVibGljIGtleXMpXG4gICAqIEBwYXJhbSBwYXJhbXMuc2lnbmVyIC0gTG9jYWwgYWNjb3VudCB1c2VkIGZvciBzaWduaW5nIHRyYW5zYWN0aW9uc1xuICAgKiBAcGFyYW0gcGFyYW1zLm5vbmNlIC0gT3B0aW9uYWwgbm9uY2UgZm9yIGFkZHJlc3MgZ2VuZXJhdGlvbiAoZGVmYXVsdHMgdG8gMClcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBuZXcgU21hcnRXYWxsZXQgaW5zdGFuY2VcbiAgICovXG4gIGFic3RyYWN0IGNyZWF0ZVdhbGxldChwYXJhbXM6IHtcbiAgICBvd25lcnM6IEFycmF5PEFkZHJlc3MgfCBXZWJBdXRobkFjY291bnQ+O1xuICAgIHNpZ25lcjogTG9jYWxBY2NvdW50O1xuICAgIG5vbmNlPzogYmlnaW50O1xuICB9KTogUHJvbWlzZTxTbWFydFdhbGxldD47XG5cbiAgLyoqXG4gICAqIEdldCBhbiBleGlzdGluZyBzbWFydCB3YWxsZXQgaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBTbWFydFdhbGxldCBpbnN0YW5jZSBmb3IgYW4gYWxyZWFkeSBkZXBsb3llZCB3YWxsZXQuXG4gICAqIFVzZSB0aGlzIHdoZW4geW91IGtub3cgdGhlIHdhbGxldCBhZGRyZXNzIGFuZCB3YW50IHRvIGludGVyYWN0IHdpdGggaXQuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBXYWxsZXQgcmV0cmlldmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRBZGRyZXNzIC0gQWRkcmVzcyBvZiB0aGUgZGVwbG95ZWQgc21hcnQgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXMuc2lnbmVyIC0gTG9jYWwgYWNjb3VudCB1c2VkIGZvciBzaWduaW5nIHRyYW5zYWN0aW9uc1xuICAgKiBAcGFyYW0gcGFyYW1zLm93bmVySW5kZXggLSBJbmRleCBvZiB0aGUgc2lnbmVyIGluIHRoZSB3YWxsZXQncyBvd25lciBsaXN0IChkZWZhdWx0cyB0byAwKVxuICAgKiBAcmV0dXJucyBTbWFydFdhbGxldCBpbnN0YW5jZSBmb3IgdGhlIGV4aXN0aW5nIHdhbGxldFxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0V2FsbGV0KHBhcmFtczoge1xuICAgIHdhbGxldEFkZHJlc3M6IEFkZHJlc3M7XG4gICAgc2lnbmVyOiBMb2NhbEFjY291bnQ7XG4gICAgb3duZXJJbmRleD86IG51bWJlcjtcbiAgfSk6IFNtYXJ0V2FsbGV0O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZWRpY3RlZCBzbWFydCB3YWxsZXQgYWRkcmVzc1xuICAgKiBAZGVzY3JpcHRpb24gQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5pc3RpYyBhZGRyZXNzIHdoZXJlIGEgc21hcnQgd2FsbGV0IHdvdWxkIGJlIGRlcGxveWVkXG4gICAqIGdpdmVuIHRoZSBzcGVjaWZpZWQgb3duZXJzIGFuZCBub25jZS4gVXNlcyBDUkVBVEUyIGZvciBhZGRyZXNzIHByZWRpY3Rpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRyZXNzIHByZWRpY3Rpb24gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gcGFyYW1zLm93bmVycyAtIEFycmF5IG9mIHdhbGxldCBvd25lcnMgKGFkZHJlc3NlcyBvciBXZWJBdXRobiBwdWJsaWMga2V5cylcbiAgICogQHBhcmFtIHBhcmFtcy5ub25jZSAtIE5vbmNlIGZvciBhZGRyZXNzIGdlbmVyYXRpb24gKGRlZmF1bHRzIHRvIDApXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBwcmVkaWN0ZWQgd2FsbGV0IGFkZHJlc3NcbiAgICovXG4gIGFic3RyYWN0IGdldFdhbGxldEFkZHJlc3MocGFyYW1zOiB7XG4gICAgb3duZXJzOiBBcnJheTxBZGRyZXNzIHwgV2ViQXV0aG5BY2NvdW50PjtcbiAgICBub25jZT86IGJpZ2ludDtcbiAgfSk6IFByb21pc2U8QWRkcmVzcz47XG59XG4iLCJpbXBvcnQgdHlwZSB7XG4gIENyZWF0ZVNtYXJ0V2FsbGV0T3B0aW9ucyxcbiAgQ3JlYXRlV2FsbGV0V2l0aEVtYmVkZGVkU2lnbmVyT3B0aW9ucyxcbiAgR2V0RW1iZWRkZWRXYWxsZXRPcHRpb25zLFxuICBHZXRTbWFydFdhbGxldE9wdGlvbnMsXG4gIEdldFNtYXJ0V2FsbGV0V2l0aEVtYmVkZGVkU2lnbmVyT3B0aW9ucyxcbn0gZnJvbSBcIkAvdHlwZXMvd2FsbGV0XCI7XG5pbXBvcnQgdHlwZSB7IEVtYmVkZGVkV2FsbGV0IH0gZnJvbSBcIkAvd2FsbGV0L2Jhc2Uvd2FsbGV0cy9FbWJlZGRlZFdhbGxldFwiO1xuaW1wb3J0IHR5cGUgeyBTbWFydFdhbGxldCB9IGZyb20gXCJAL3dhbGxldC9iYXNlL3dhbGxldHMvU21hcnRXYWxsZXRcIjtcbmltcG9ydCB0eXBlIHsgV2FsbGV0UHJvdmlkZXIgfSBmcm9tIFwiQC93YWxsZXQvV2FsbGV0UHJvdmlkZXJcIjtcblxuLy8gV0hBVCBJUyBUSElTIENMQVNTP1xuLy8gQmFzaWNhbGx5IHRoaXMgaXMgYSB3YWxsZXQgY2xhc3MgdGhhdCBpcyBjb25uZWN0ZWQgdG8gYSBwYXJ0aWN1bGFyIHVzZXIuXG4vLyBBbGwgZnVydGhlciBmdW5jdGlvbmFsaXRpZXMgdGhhdCBhcmUgcmVsYXRlZCB0byBhIHdhbGxldCBzaG91bGQgYmUgYWRkZWQgaGVyZSBhbmQgc2hvdWxkIGJlIHByb3ZpZGVkIHRocm91Z2ggdGhpcyBjbGFzc1xuXG4vKipcbiAqIFdhbGxldCBuYW1lc3BhY2UgdGhhdCBwcm92aWRlcyB1bmlmaWVkIHdhbGxldCBvcGVyYXRpb25zXG4gKiBAZGVzY3JpcHRpb24gUHJvdmlkZXMgYWNjZXNzIHRvIHdhbGxldCBmdW5jdGlvbmFsaXR5IHRocm91Z2ggYSBzaW5nbGUgcHJvdmlkZXIgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBjbGFzcyBXYWxsZXROYW1lc3BhY2Uge1xuICBwcml2YXRlIHByb3ZpZGVyOiBXYWxsZXRQcm92aWRlcjtcblxuICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogV2FsbGV0UHJvdmlkZXIpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRpcmVjdCBhY2Nlc3MgdG8gdGhlIGVtYmVkZGVkIHdhbGxldCBwcm92aWRlclxuICAgKiBAZGVzY3JpcHRpb24gUHJvdmlkZXMgZGlyZWN0IGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBlbWJlZGRlZCB3YWxsZXQgcHJvdmlkZXIgd2hlblxuICAgKiBhZHZhbmNlZCBmdW5jdGlvbmFsaXR5IGJleW9uZCB0aGUgdW5pZmllZCBpbnRlcmZhY2UgaXMgbmVlZGVkXG4gICAqIEByZXR1cm5zIFRoZSBjb25maWd1cmVkIGVtYmVkZGVkIHdhbGxldCBwcm92aWRlciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IGVtYmVkZGVkV2FsbGV0UHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZW1iZWRkZWRXYWxsZXRQcm92aWRlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGlyZWN0IGFjY2VzcyB0byB0aGUgc21hcnQgd2FsbGV0IHByb3ZpZGVyXG4gICAqIEBkZXNjcmlwdGlvbiBQcm92aWRlcyBkaXJlY3QgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIHNtYXJ0IHdhbGxldCBwcm92aWRlciB3aGVuXG4gICAqIGFkdmFuY2VkIGZ1bmN0aW9uYWxpdHkgYmV5b25kIHRoZSB1bmlmaWVkIGludGVyZmFjZSBpcyBuZWVkZWRcbiAgICogQHJldHVybnMgVGhlIGNvbmZpZ3VyZWQgc21hcnQgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gICAqL1xuICBnZXQgc21hcnRXYWxsZXRQcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zbWFydFdhbGxldFByb3ZpZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBlbWJlZGRlZCB3YWxsZXRcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgb25seSBhbiBlbWJlZGRlZCB3YWxsZXQgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgZW1iZWRkZWQgd2FsbGV0IHByb3ZpZGVyLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCBlbWJlZGRlZCB3YWxsZXQgaW5zdGFuY2VcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUVtYmVkZGVkV2FsbGV0KCk6IFByb21pc2U8RW1iZWRkZWRXYWxsZXQ+IHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5jcmVhdGVFbWJlZGRlZFdhbGxldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzbWFydCB3YWxsZXRcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgb25seSBhIHNtYXJ0IHdhbGxldCB1c2luZyB0aGUgY29uZmlndXJlZCBzbWFydCB3YWxsZXQgcHJvdmlkZXIuXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IGFscmVhZHkgaGF2ZSBhIHNpZ25lciBhbmQgd2FudCB0byBjcmVhdGUgYSBzbWFydCB3YWxsZXQgd2l0aG91dFxuICAgKiBjcmVhdGluZyBhbiBlbWJlZGRlZCB3YWxsZXQuIFlvdSBtdXN0IHByb3ZpZGUgeW91ciBvd24gc2lnbmVyIGFuZCBvd25lcnMgYXJyYXkuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTbWFydCB3YWxsZXQgY3JlYXRpb24gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gcGFyYW1zLm93bmVycyAtIEFycmF5IG9mIG93bmVycyBmb3IgdGhlIHNtYXJ0IHdhbGxldCAoYWRkcmVzc2VzIG9yIFdlYkF1dGhuIHB1YmxpYyBrZXlzKVxuICAgKiBAcGFyYW0gcGFyYW1zLnNpZ25lciAtIExvY2FsIGFjY291bnQgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtcy5ub25jZSAtIE9wdGlvbmFsIG5vbmNlIGZvciBzbWFydCB3YWxsZXQgYWRkcmVzcyBnZW5lcmF0aW9uIChkZWZhdWx0cyB0byAwKVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCBzbWFydCB3YWxsZXQgaW5zdGFuY2VcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNtYXJ0V2FsbGV0KFxuICAgIHBhcmFtczogQ3JlYXRlU21hcnRXYWxsZXRPcHRpb25zXG4gICk6IFByb21pc2U8U21hcnRXYWxsZXQ+IHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5jcmVhdGVTbWFydFdhbGxldChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzbWFydCB3YWxsZXQgd2l0aCBlbWJlZGRlZCB3YWxsZXQgYXMgc2lnbmVyXG4gICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGJvdGggYW4gZW1iZWRkZWQgd2FsbGV0IGFuZCBhIHNtYXJ0IHdhbGxldCwgd2l0aCB0aGUgZW1iZWRkZWQgd2FsbGV0XG4gICAqIGF1dG9tYXRpY2FsbHkgYWRkZWQgYXMgb25lIG9mIHRoZSBvd25lcnMvc2lnbmVycyBvZiB0aGUgc21hcnQgd2FsbGV0LlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgd2FsbGV0IGNyZWF0aW9uIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHBhcmFtcy5vd25lcnMgLSBPcHRpb25hbCBhcnJheSBvZiBhZGRpdGlvbmFsIG93bmVycyBmb3IgdGhlIHNtYXJ0IHdhbGxldC4gVGhlIGVtYmVkZGVkIHdhbGxldCB3aWxsIGJlIGFkZGVkIHRvIHRoaXMgYXJyYXkgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICogQHBhcmFtIHBhcmFtcy5lbWJlZGRlZFdhbGxldEluZGV4IC0gT3B0aW9uYWwgaW5kZXggd2hlcmUgdGhlIGVtYmVkZGVkIHdhbGxldCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW4gdGhlIG93bmVycyBhcnJheS4gSWYgbm90IHNwZWNpZmllZCwgZW1iZWRkZWQgd2FsbGV0IGlzIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgKiBAcGFyYW0gcGFyYW1zLm5vbmNlIC0gT3B0aW9uYWwgbm9uY2UgZm9yIHNtYXJ0IHdhbGxldCBhZGRyZXNzIGdlbmVyYXRpb24gKGRlZmF1bHRzIHRvIDApXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjcmVhdGVkIHNtYXJ0IHdhbGxldCBpbnN0YW5jZVxuICAgKi9cbiAgYXN5bmMgY3JlYXRlV2FsbGV0V2l0aEVtYmVkZGVkU2lnbmVyKFxuICAgIHBhcmFtcz86IENyZWF0ZVdhbGxldFdpdGhFbWJlZGRlZFNpZ25lck9wdGlvbnNcbiAgKTogUHJvbWlzZTxTbWFydFdhbGxldD4ge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmNyZWF0ZVdhbGxldFdpdGhFbWJlZGRlZFNpZ25lcihwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBleGlzdGluZyBzbWFydCB3YWxsZXQgdXNpbmcgZW1iZWRkZWQgd2FsbGV0IGFzIHNpZ25lclxuICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIGFuIGVtYmVkZGVkIHdhbGxldCBieSB3YWxsZXRJZCBhbmQgdXNlcyBpdCBhcyB0aGUgc2lnbmVyIHRvIGdldFxuICAgKiB0aGUgY29ycmVzcG9uZGluZyBzbWFydCB3YWxsZXQuIElmIG5laXRoZXIgd2FsbGV0QWRkcmVzcyBub3IgZGVwbG95bWVudE93bmVycyBpcyBwcm92aWRlZCxcbiAgICogZGVmYXVsdHMgdG8gdXNpbmcgdGhlIGVtYmVkZGVkIHdhbGxldCBhcyB0aGUgc2luZ2xlIG93bmVyLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBoYXZlXG4gICAqIGFuIGVtYmVkZGVkIHdhbGxldCBJRCBhbmQgd2FudCB0byBhY2Nlc3MgdGhlIGFzc29jaWF0ZWQgc21hcnQgd2FsbGV0IGZ1bmN0aW9uYWxpdHkuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBXYWxsZXQgcmV0cmlldmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRJZCAtIElEIG9mIHRoZSBlbWJlZGRlZCB3YWxsZXQgdG8gdXNlIGFzIHNpZ25lclxuICAgKiBAcGFyYW0gcGFyYW1zLmRlcGxveW1lbnRPd25lcnMgLSBPcHRpb25hbCBhcnJheSBvZiBvcmlnaW5hbCBkZXBsb3ltZW50IG93bmVycyBmb3Igc21hcnQgd2FsbGV0IGFkZHJlc3MgY2FsY3VsYXRpb24uIElmIG5vdCBwcm92aWRlZCBhbmQgd2FsbGV0QWRkcmVzcyBpcyBhbHNvIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gdXNpbmcgdGhlIGVtYmVkZGVkIHdhbGxldCBhcyBzaW5nbGUgb3duZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMuc2lnbmVyT3duZXJJbmRleCAtIEN1cnJlbnQgaW5kZXggb2YgdGhlIHNpZ25lciBpbiB0aGUgc21hcnQgd2FsbGV0J3MgY3VycmVudCBvd25lcnMgYXJyYXkgKHVzZWQgZm9yIHRyYW5zYWN0aW9uIHNpZ25pbmcpLiBEZWZhdWx0cyB0byAwIGlmIG5vdCBzcGVjaWZpZWQuIFRoaXMgbWF5IGRpZmZlciBmcm9tIHRoZSBvcmlnaW5hbCBkZXBsb3ltZW50IGluZGV4IGlmIG93bmVycyBoYXZlIGJlZW4gbW9kaWZpZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0QWRkcmVzcyAtIE9wdGlvbmFsIGV4cGxpY2l0IHNtYXJ0IHdhbGxldCBhZGRyZXNzIChza2lwcyBhZGRyZXNzIGNhbGN1bGF0aW9uKVxuICAgKiBAcGFyYW0gcGFyYW1zLm5vbmNlIC0gT3B0aW9uYWwgbm9uY2UgdXNlZCBkdXJpbmcgc21hcnQgd2FsbGV0IGNyZWF0aW9uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzbWFydCB3YWxsZXQgaW5zdGFuY2Ugd2l0aCBlbWJlZGRlZCB3YWxsZXQgYXMgc2lnbmVyXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgZW1iZWRkZWQgd2FsbGV0IGlzIG5vdCBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0U21hcnRXYWxsZXRXaXRoRW1iZWRkZWRTaWduZXIoXG4gICAgcGFyYW1zOiBHZXRTbWFydFdhbGxldFdpdGhFbWJlZGRlZFNpZ25lck9wdGlvbnNcbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0U21hcnRXYWxsZXRXaXRoRW1iZWRkZWRTaWduZXIocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gZXhpc3RpbmcgZW1iZWRkZWQgd2FsbGV0XG4gICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgYW4gZW1iZWRkZWQgd2FsbGV0IGJ5IHdhbGxldElkLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIGFuIGVtYmVkZGVkIHdhbGxldCBJRCBhbmRcbiAgICogd2FudCB0byBhY2Nlc3MgdGhlIGFzc29jaWF0ZWQgZW1iZWRkZWQgd2FsbGV0IGZ1bmN0aW9uYWxpdHkuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBXYWxsZXQgcmV0cmlldmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRJZCAtIElEIG9mIHRoZSBlbWJlZGRlZCB3YWxsZXQgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGVtYmVkZGVkIHdhbGxldCBpbnN0YW5jZVxuICAgKi9cbiAgYXN5bmMgZ2V0RW1iZWRkZWRXYWxsZXQocGFyYW1zOiBHZXRFbWJlZGRlZFdhbGxldE9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRFbWJlZGRlZFdhbGxldChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBleGlzdGluZyBzbWFydCB3YWxsZXQgd2l0aCBhIHByb3ZpZGVkIHNpZ25lclxuICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIGEgc21hcnQgd2FsbGV0IHVzaW5nIGEgZGlyZWN0bHkgcHJvdmlkZWQgc2lnbmVyLiBUaGlzIGlzIHVzZWZ1bCB3aGVuXG4gICAqIHlvdSBhbHJlYWR5IGhhdmUgYSBMb2NhbEFjY291bnQgc2lnbmVyIGFuZCB3YW50IHRvIGFjY2VzcyBhbiBleGlzdGluZyBzbWFydCB3YWxsZXQgd2l0aG91dFxuICAgKiBnb2luZyB0aHJvdWdoIHRoZSBlbWJlZGRlZCB3YWxsZXQgcHJvdmlkZXIuIFVzZSB0aGlzIGluc3RlYWQgb2YgZ2V0U21hcnRXYWxsZXRXaXRoRW1iZWRkZWRTaWduZXJcbiAgICogd2hlbiB5b3UgaGF2ZSBkaXJlY3QgY29udHJvbCBvdmVyIHRoZSBzaWduZXIuXG4gICAqIEBwYXJhbSBzaWduZXIgLSBMb2NhbCBhY2NvdW50IHRvIHVzZSBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMgb24gdGhlIHNtYXJ0IHdhbGxldFxuICAgKiBAcGFyYW0gZ2V0V2FsbGV0UGFyYW1zIC0gV2FsbGV0IHJldHJpZXZhbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBnZXRXYWxsZXRQYXJhbXMuZGVwbG95bWVudE93bmVycyAtIEFycmF5IG9mIG9yaWdpbmFsIGRlcGxveW1lbnQgb3duZXJzIGZvciBzbWFydCB3YWxsZXQgYWRkcmVzcyBjYWxjdWxhdGlvbi4gUmVxdWlyZWQgaWYgd2FsbGV0QWRkcmVzcyBub3QgcHJvdmlkZWQuIE11c3QgbWF0Y2ggdGhlIGV4YWN0IG93bmVycyBhcnJheSB1c2VkIGR1cmluZyB3YWxsZXQgZGVwbG95bWVudC5cbiAgICogQHBhcmFtIGdldFdhbGxldFBhcmFtcy5zaWduZXJPd25lckluZGV4IC0gQ3VycmVudCBpbmRleCBvZiB0aGUgc2lnbmVyIGluIHRoZSBzbWFydCB3YWxsZXQncyBjdXJyZW50IG93bmVycyBhcnJheSAodXNlZCBmb3IgdHJhbnNhY3Rpb24gc2lnbmluZykuIERlZmF1bHRzIHRvIDAgaWYgbm90IHNwZWNpZmllZC4gVGhpcyBtYXkgZGlmZmVyIGZyb20gdGhlIG9yaWdpbmFsIGRlcGxveW1lbnQgaW5kZXggaWYgb3duZXJzIGhhdmUgYmVlbiBtb2RpZmllZC5cbiAgICogQHBhcmFtIGdldFdhbGxldFBhcmFtcy53YWxsZXRBZGRyZXNzIC0gT3B0aW9uYWwgZXhwbGljaXQgc21hcnQgd2FsbGV0IGFkZHJlc3MgKHNraXBzIGFkZHJlc3MgY2FsY3VsYXRpb24pXG4gICAqIEBwYXJhbSBnZXRXYWxsZXRQYXJhbXMubm9uY2UgLSBPcHRpb25hbCBub25jZSB1c2VkIGR1cmluZyBzbWFydCB3YWxsZXQgY3JlYXRpb25cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHNtYXJ0IHdhbGxldCBpbnN0YW5jZSB3aXRoIHRoZSBwcm92aWRlZCBzaWduZXJcbiAgICogQHRocm93cyBFcnJvciBpZiBuZWl0aGVyIHdhbGxldEFkZHJlc3Mgbm9yIGRlcGxveW1lbnRPd25lcnMgcHJvdmlkZWRcbiAgICovXG4gIGFzeW5jIGdldFNtYXJ0V2FsbGV0KHBhcmFtczogR2V0U21hcnRXYWxsZXRPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0U21hcnRXYWxsZXQocGFyYW1zKTtcbiAgfVxufVxuIiwiZXhwb3J0IHR5cGUgeyBTbWFydFdhbGxldCB9IGZyb20gXCJAL3dhbGxldC9iYXNlL3dhbGxldHMvU21hcnRXYWxsZXRcIjtcbmV4cG9ydCB0eXBlIHsgRW1iZWRkZWRXYWxsZXQgfSBmcm9tIFwiQC93YWxsZXQvYmFzZS93YWxsZXRzL0VtYmVkZGVkV2FsbGV0XCI7XG5leHBvcnQgdHlwZSB7IFdhbGxldE5hbWVzcGFjZSB9IGZyb20gXCJAL3dhbGxldC9XYWxsZXROYW1lc3BhY2VcIjtcbmV4cG9ydCB0eXBlIHsgQ2hhaW5NYW5hZ2VyIH0gZnJvbSBcIkAvdG9vbHMvQ2hhaW5NYW5hZ2VyXCI7XG5leHBvcnQgdHlwZSB7IFRva2VuQmFsYW5jZSB9IGZyb20gXCJAL3R5cGVzL3Rva2VuXCI7XG5cbmltcG9ydCB7IENoYWluTWFuYWdlciB9IGZyb20gXCJAL3Rvb2xzL0NoYWluTWFuYWdlclwiO1xuaW1wb3J0IHsgU21hcnRXYWxsZXRQcm92aWRlciB9IGZyb20gXCJAL3dhbGxldC9iYXNlL3Byb3ZpZGVycy9TbWFydFdhbGxldFByb3ZpZGVyXCI7XG5pbXBvcnQgeyBXYWxsZXROYW1lc3BhY2UgfSBmcm9tIFwiQC93YWxsZXQvV2FsbGV0TmFtZXNwYWNlXCI7XG5pbXBvcnQgeyB0eXBlIE15Y2VsaXVtU0RLQ29uZmlnIH0gZnJvbSBcIkAvdHlwZXMvc2RrXCI7XG5pbXBvcnQgeyB1bmljaGFpbiB9IGZyb20gXCJ2aWVtL2NoYWluc1wiO1xuaW1wb3J0IHsgRGVmYXVsdFNtYXJ0V2FsbGV0UHJvdmlkZXIgfSBmcm9tIFwiQC93YWxsZXQvcHJvdmlkZXJzL0RlZmF1bHRTbWFydFdhbGxldFByb3ZpZGVyXCI7XG5pbXBvcnQgeyBXYWxsZXRQcm92aWRlciB9IGZyb20gXCJAL3dhbGxldC9XYWxsZXRQcm92aWRlclwiO1xuaW1wb3J0IHR5cGUgeyBFbWJlZGRlZFdhbGxldFByb3ZpZGVyIH0gZnJvbSBcIkAvd2FsbGV0L2Jhc2UvcHJvdmlkZXJzL0VtYmVkZGVkV2FsbGV0UHJvdmlkZXJcIjtcbmltcG9ydCB7IFByaXZ5RW1iZWRkZWRXYWxsZXRQcm92aWRlciB9IGZyb20gXCIuL3dhbGxldC9wcm92aWRlcnMvUHJpdnlFbWJlZGRlZFdhbGxldFByb3ZpZGVyXCI7XG5pbXBvcnQgeyBQcml2eUNsaWVudCB9IGZyb20gXCJAcHJpdnktaW8vc2VydmVyLWF1dGhcIjtcblxuZXhwb3J0IGNsYXNzIE15Y2VsaXVtU0RLIHtcbiAgcHVibGljIHJlYWRvbmx5IHdhbGxldDogV2FsbGV0TmFtZXNwYWNlO1xuICBwcml2YXRlIF9jaGFpbk1hbmFnZXI6IENoYWluTWFuYWdlcjtcbiAgLy8gcHJpdmF0ZSBsZW5kUHJvdmlkZXI/OiBMZW5kUHJvdmlkZXI7XG4gIHByaXZhdGUgZW1iZWRkZWRXYWxsZXRQcm92aWRlciE6IEVtYmVkZGVkV2FsbGV0UHJvdmlkZXI7XG4gIHByaXZhdGUgc21hcnRXYWxsZXRQcm92aWRlciE6IFNtYXJ0V2FsbGV0UHJvdmlkZXI7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBNeWNlbGl1bVNES0NvbmZpZykge1xuICAgIHRoaXMuX2NoYWluTWFuYWdlciA9IG5ldyBDaGFpbk1hbmFnZXIoXG4gICAgICBjb25maWcuY2hhaW5zIHx8IFtcbiAgICAgICAge1xuICAgICAgICAgIGNoYWluSWQ6IHVuaWNoYWluLmlkLFxuICAgICAgICAgIHJwY1VybDogdW5pY2hhaW4ucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgICAgIH0sXG4gICAgICBdXG4gICAgKTtcblxuICAgIHRoaXMud2FsbGV0ID0gdGhpcy5jcmVhdGVXYWxsZXROYW1lc3BhY2UoY29uZmlnLndhbGxldHNDb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2hhaW4gbWFuYWdlciBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyBDaGFpbk1hbmFnZXIgaW5zdGFuY2UgZm9yIG11bHRpLWNoYWluIG9wZXJhdGlvbnNcbiAgICovXG4gIGdldCBjaGFpbk1hbmFnZXIoKTogQ2hhaW5NYW5hZ2VyIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW5NYW5hZ2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgd2FsbGV0IHByb3ZpZGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSBjb25maWcgLSBXYWxsZXQgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJucyBXYWxsZXRQcm92aWRlciBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVXYWxsZXRQcm92aWRlcihjb25maWc6IE15Y2VsaXVtU0RLQ29uZmlnW1wid2FsbGV0c0NvbmZpZ1wiXSkge1xuICAgIGlmIChjb25maWcuZW1iZWRkZWRXYWxsZXRDb25maWcucHJvdmlkZXIudHlwZSA9PT0gXCJwcml2eVwiKSB7XG4gICAgICBjb25zdCBwcml2eUNsaWVudCA9IG5ldyBQcml2eUNsaWVudChcbiAgICAgICAgY29uZmlnLmVtYmVkZGVkV2FsbGV0Q29uZmlnLnByb3ZpZGVyLnByb3ZpZGVyQ29uZmlnLmFwcElkLFxuICAgICAgICBjb25maWcuZW1iZWRkZWRXYWxsZXRDb25maWcucHJvdmlkZXIucHJvdmlkZXJDb25maWcuYXBwU2VjcmV0XG4gICAgICApO1xuXG4gICAgICB0aGlzLmVtYmVkZGVkV2FsbGV0UHJvdmlkZXIgPSBuZXcgUHJpdnlFbWJlZGRlZFdhbGxldFByb3ZpZGVyKFxuICAgICAgICAvLyBjb25maWcuZW1iZWRkZWRXYWxsZXRDb25maWcucHJvdmlkZXIucHJpdnlDbGllbnQsXG4gICAgICAgIHByaXZ5Q2xpZW50LFxuICAgICAgICB0aGlzLl9jaGFpbk1hbmFnZXJcbiAgICAgICAgLy8gdGhpcy5sZW5kUHJvdmlkZXIhXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbnN1cHBvcnRlZCBlbWJlZGRlZCB3YWxsZXQgcHJvdmlkZXI6ICR7Y29uZmlnLmVtYmVkZGVkV2FsbGV0Q29uZmlnLnByb3ZpZGVyLnR5cGV9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhY29uZmlnLnNtYXJ0V2FsbGV0Q29uZmlnIHx8XG4gICAgICBjb25maWcuc21hcnRXYWxsZXRDb25maWcucHJvdmlkZXIudHlwZSA9PT0gXCJkZWZhdWx0XCJcbiAgICApIHtcbiAgICAgIHRoaXMuc21hcnRXYWxsZXRQcm92aWRlciA9IG5ldyBEZWZhdWx0U21hcnRXYWxsZXRQcm92aWRlcihcbiAgICAgICAgdGhpcy5jaGFpbk1hbmFnZXJcbiAgICAgICAgLy8gdGhpcy5sZW5kXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBVbnN1cHBvcnRlZCBzbWFydCB3YWxsZXQgcHJvdmlkZXI6ICR7Y29uZmlnLnNtYXJ0V2FsbGV0Q29uZmlnLnByb3ZpZGVyLnR5cGV9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB3YWxsZXRQcm92aWRlciA9IG5ldyBXYWxsZXRQcm92aWRlcihcbiAgICAgIHRoaXMuZW1iZWRkZWRXYWxsZXRQcm92aWRlcixcbiAgICAgIHRoaXMuc21hcnRXYWxsZXRQcm92aWRlclxuICAgICk7XG5cbiAgICByZXR1cm4gd2FsbGV0UHJvdmlkZXI7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSB3YWxsZXQgbmFtZXNwYWNlIGluc3RhbmNlXG4gICAqIEBwYXJhbSBjb25maWcgLSBXYWxsZXQgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJucyBXYWxsZXROYW1lc3BhY2UgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlV2FsbGV0TmFtZXNwYWNlKGNvbmZpZzogTXljZWxpdW1TREtDb25maWdbXCJ3YWxsZXRzQ29uZmlnXCJdKSB7XG4gICAgY29uc3Qgd2FsbGV0UHJvdmlkZXIgPSB0aGlzLmNyZWF0ZVdhbGxldFByb3ZpZGVyKGNvbmZpZyk7XG4gICAgcmV0dXJuIG5ldyBXYWxsZXROYW1lc3BhY2Uod2FsbGV0UHJvdmlkZXIpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE15Y2VsaXVtU0RLO1xuIiwiaW1wb3J0IHR5cGUgeyBBZGRyZXNzLCBMb2NhbEFjY291bnQgfSBmcm9tIFwidmllbVwiO1xuaW1wb3J0IHsgcGFkIH0gZnJvbSBcInZpZW1cIjtcbmltcG9ydCB7IHR5cGUgV2ViQXV0aG5BY2NvdW50IH0gZnJvbSBcInZpZW0vYWNjb3VudC1hYnN0cmFjdGlvblwiO1xuXG5pbXBvcnQgeyBzbWFydFdhbGxldEZhY3RvcnlBYmkgfSBmcm9tIFwiQC9hYmlzL3NtYXJ0V2FsbGV0RmFjdG9yeVwiO1xuaW1wb3J0IHsgc21hcnRXYWxsZXRGYWN0b3J5QWRkcmVzcyB9IGZyb20gXCJAL2NvbnN0YW50cy9hZGRyZXNzZXNcIjtcbmltcG9ydCB0eXBlIHsgQ2hhaW5NYW5hZ2VyIH0gZnJvbSBcIkAvdG9vbHMvQ2hhaW5NYW5hZ2VyXCI7XG4vLyBpbXBvcnQgdHlwZSB7IExlbmRQcm92aWRlciB9IGZyb20gXCJAL3R5cGVzL2xlbmQuanNcIjtcbmltcG9ydCB7IERlZmF1bHRTbWFydFdhbGxldCB9IGZyb20gXCJAL3dhbGxldC9EZWZhdWx0U21hcnRXYWxsZXRcIjtcbmltcG9ydCB7IFNtYXJ0V2FsbGV0UHJvdmlkZXIgfSBmcm9tIFwiQC93YWxsZXQvYmFzZS9wcm92aWRlcnMvU21hcnRXYWxsZXRQcm92aWRlclwiO1xuXG4vKipcbiAqIFNtYXJ0IFdhbGxldCBQcm92aWRlclxuICogQGRlc2NyaXB0aW9uIEZhY3RvcnkgZm9yIGNyZWF0aW5nIGFuZCBtYW5hZ2luZyBTbWFydCBXYWxsZXQgaW5zdGFuY2VzLlxuICogSGFuZGxlcyB3YWxsZXQgYWRkcmVzcyBwcmVkaWN0aW9uLCBjcmVhdGlvbiwgYW5kIHJldHJpZXZhbCB1c2luZyBFUkMtNDMzNyBhY2NvdW50IGFic3RyYWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdFNtYXJ0V2FsbGV0UHJvdmlkZXIgZXh0ZW5kcyBTbWFydFdhbGxldFByb3ZpZGVyIHtcbiAgLyoqIE1hbmFnZXMgc3VwcG9ydGVkIGJsb2NrY2hhaW4gbmV0d29ya3MgKi9cbiAgcHJpdmF0ZSBjaGFpbk1hbmFnZXI6IENoYWluTWFuYWdlcjtcbiAgLyoqIFByb3ZpZGVyIGZvciBsZW5kaW5nIG1hcmtldCBvcGVyYXRpb25zICovXG4gIC8vICAgcHJpdmF0ZSBsZW5kUHJvdmlkZXI6IExlbmRQcm92aWRlcjtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgU21hcnQgV2FsbGV0IFByb3ZpZGVyXG4gICAqIEBwYXJhbSBjaGFpbk1hbmFnZXIgLSBNYW5hZ2VzIHN1cHBvcnRlZCBibG9ja2NoYWluIG5ldHdvcmtzXG4gICAqIEBwYXJhbSBwYXltYXN0ZXJBbmRCdW5kbGVyVXJsIC0gVVJMIGZvciBFUkMtNDMzNyBidW5kbGVyIGFuZCBwYXltYXN0ZXIgc2VydmljZXNcbiAgICogQHBhcmFtIGxlbmRQcm92aWRlciAtIFByb3ZpZGVyIGZvciBsZW5kaW5nIG1hcmtldCBvcGVyYXRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjaGFpbk1hbmFnZXI6IENoYWluTWFuYWdlcikge1xuICAgIC8vICBsZW5kUHJvdmlkZXI6IExlbmRQcm92aWRlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFpbk1hbmFnZXIgPSBjaGFpbk1hbmFnZXI7XG4gICAgLy8gdGhpcy5sZW5kUHJvdmlkZXIgPSBsZW5kUHJvdmlkZXI7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHNtYXJ0IHdhbGxldCBpbnN0YW5jZVxuICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIG5ldyBzbWFydCB3YWxsZXQgdGhhdCB3aWxsIGJlIGRlcGxveWVkIG9uIGZpcnN0IHRyYW5zYWN0aW9uLlxuICAgKiBUaGUgd2FsbGV0IGFkZHJlc3MgaXMgZGV0ZXJtaW5pc3RpY2FsbHkgY2FsY3VsYXRlZCBmcm9tIG93bmVycyBhbmQgbm9uY2UuXG4gICAqIEBwYXJhbSBvd25lcnMgLSBBcnJheSBvZiB3YWxsZXQgb3duZXJzIChhZGRyZXNzZXMgb3IgV2ViQXV0aG4gcHVibGljIGtleXMpXG4gICAqIEBwYXJhbSBzaWduZXIgLSBMb2NhbCBhY2NvdW50IHVzZWQgZm9yIHNpZ25pbmcgdHJhbnNhY3Rpb25zXG4gICAqIEBwYXJhbSBub25jZSAtIE9wdGlvbmFsIG5vbmNlIGZvciBhZGRyZXNzIGdlbmVyYXRpb24gKGRlZmF1bHRzIHRvIDApXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgbmV3IFNtYXJ0V2FsbGV0IGluc3RhbmNlXG4gICAqL1xuICBhc3luYyBjcmVhdGVXYWxsZXQocGFyYW1zOiB7XG4gICAgb3duZXJzOiBBcnJheTxBZGRyZXNzIHwgV2ViQXV0aG5BY2NvdW50PjtcbiAgICBzaWduZXI6IExvY2FsQWNjb3VudDtcbiAgICBub25jZT86IGJpZ2ludDtcbiAgfSk6IFByb21pc2U8RGVmYXVsdFNtYXJ0V2FsbGV0PiB7XG4gICAgY29uc3QgeyBvd25lcnMsIHNpZ25lciwgbm9uY2UgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gbmV3IERlZmF1bHRTbWFydFdhbGxldChcbiAgICAgIG93bmVycyxcbiAgICAgIHNpZ25lcixcbiAgICAgIHRoaXMuY2hhaW5NYW5hZ2VyLFxuICAgICAgLy8gICB0aGlzLmxlbmRQcm92aWRlcixcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIG5vbmNlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByZWRpY3RlZCBzbWFydCB3YWxsZXQgYWRkcmVzc1xuICAgKiBAZGVzY3JpcHRpb24gQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5pc3RpYyBhZGRyZXNzIHdoZXJlIGEgc21hcnQgd2FsbGV0IHdvdWxkIGJlIGRlcGxveWVkXG4gICAqIGdpdmVuIHRoZSBzcGVjaWZpZWQgb3duZXJzIGFuZCBub25jZS4gVXNlcyBDUkVBVEUyIGZvciBhZGRyZXNzIHByZWRpY3Rpb24uXG4gICAqIEBwYXJhbSBwYXJhbXMub3duZXJzIC0gQXJyYXkgb2Ygd2FsbGV0IG93bmVycyAoYWRkcmVzc2VzIG9yIFdlYkF1dGhuIHB1YmxpYyBrZXlzKVxuICAgKiBAcGFyYW0gcGFyYW1zLm5vbmNlIC0gTm9uY2UgZm9yIGFkZHJlc3MgZ2VuZXJhdGlvbiAoZGVmYXVsdHMgdG8gMClcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHByZWRpY3RlZCB3YWxsZXQgYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgZ2V0V2FsbGV0QWRkcmVzcyhwYXJhbXM6IHtcbiAgICBvd25lcnM6IEFycmF5PEFkZHJlc3MgfCBXZWJBdXRobkFjY291bnQ+O1xuICAgIG5vbmNlPzogYmlnaW50O1xuICB9KSB7XG4gICAgY29uc3QgeyBvd25lcnMsIG5vbmNlID0gMG4gfSA9IHBhcmFtcztcbiAgICBjb25zdCBvd25lcnNfYnl0ZXMgPSBvd25lcnMubWFwKChvd25lcikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvd25lciA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHBhZChvd25lcik7XG4gICAgICBpZiAob3duZXIudHlwZSA9PT0gXCJ3ZWJBdXRoblwiKSByZXR1cm4gb3duZXIucHVibGljS2V5O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvd25lciB0eXBlXCIpO1xuICAgIH0pO1xuXG4gICAgLy8gRmFjdG9yeSBpcyB0aGUgc2FtZSBhY2Nyb3NzIGFsbCBjaGFpbnMsIHNvIHdlIGNhbiB1c2UgdGhlIGZpcnN0IGNoYWluIHRvIGdldCB0aGUgd2FsbGV0IGFkZHJlc3NcbiAgICBjb25zdCBzdXBwb3J0ZWRDaGFpbnMgPSB0aGlzLmNoYWluTWFuYWdlci5nZXRTdXBwb3J0ZWRDaGFpbnMoKTtcbiAgICBpZiAoIXN1cHBvcnRlZENoYWlucy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1cHBvcnRlZCBjaGFpbnMgY29uZmlndXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljQ2xpZW50ID0gdGhpcy5jaGFpbk1hbmFnZXIuZ2V0UHVibGljQ2xpZW50KHN1cHBvcnRlZENoYWluc1swXSEpO1xuICAgIGNvbnN0IHNtYXJ0V2FsbGV0QWRkcmVzcyA9IGF3YWl0IHB1YmxpY0NsaWVudC5yZWFkQ29udHJhY3Qoe1xuICAgICAgYWJpOiBzbWFydFdhbGxldEZhY3RvcnlBYmksXG4gICAgICBhZGRyZXNzOiBzbWFydFdhbGxldEZhY3RvcnlBZGRyZXNzLFxuICAgICAgZnVuY3Rpb25OYW1lOiBcImdldEFkZHJlc3NcIixcbiAgICAgIGFyZ3M6IFtvd25lcnNfYnl0ZXMsIG5vbmNlXSxcbiAgICB9KTtcbiAgICByZXR1cm4gc21hcnRXYWxsZXRBZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBleGlzdGluZyBzbWFydCB3YWxsZXQgaW5zdGFuY2VcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBTbWFydFdhbGxldCBpbnN0YW5jZSBmb3IgYW4gYWxyZWFkeSBkZXBsb3llZCB3YWxsZXQuXG4gICAqIFVzZSB0aGlzIHdoZW4geW91IGtub3cgdGhlIHdhbGxldCBhZGRyZXNzIGFuZCB3YW50IHRvIGludGVyYWN0IHdpdGggaXQuXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0QWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIGRlcGxveWVkIHNtYXJ0IHdhbGxldFxuICAgKiBAcGFyYW0gcGFyYW1zLnNpZ25lciAtIExvY2FsIGFjY291bnQgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtcy5vd25lckluZGV4IC0gSW5kZXggb2YgdGhlIHNpZ25lciBpbiB0aGUgd2FsbGV0J3Mgb3duZXIgbGlzdCAoZGVmYXVsdHMgdG8gMClcbiAgICogQHJldHVybnMgU21hcnRXYWxsZXQgaW5zdGFuY2VcbiAgICovXG4gIGdldFdhbGxldChwYXJhbXM6IHtcbiAgICB3YWxsZXRBZGRyZXNzOiBBZGRyZXNzO1xuICAgIHNpZ25lcjogTG9jYWxBY2NvdW50O1xuICAgIG93bmVySW5kZXg/OiBudW1iZXI7XG4gIH0pOiBEZWZhdWx0U21hcnRXYWxsZXQge1xuICAgIGNvbnN0IHsgd2FsbGV0QWRkcmVzcywgc2lnbmVyLCBvd25lckluZGV4IH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIG5ldyBEZWZhdWx0U21hcnRXYWxsZXQoXG4gICAgICBbc2lnbmVyLmFkZHJlc3NdLFxuICAgICAgc2lnbmVyLFxuICAgICAgdGhpcy5jaGFpbk1hbmFnZXIsXG4gICAgICAvLyAgIHRoaXMubGVuZFByb3ZpZGVyLFxuICAgICAgd2FsbGV0QWRkcmVzcyxcbiAgICAgIG93bmVySW5kZXhcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmQgdGhlIHdhbGxldCB2aWEgYSBmYXVjZXRcbiAgICogQGRlc2NyaXB0aW9uIEZ1bmRzIHRoZSBjdXJyZW50IHdhbGxldCB2aWEgYSBmYXVjZXQuIENhbiBvbmx5IHdvcmsgaWYgYSBzZWxlY3RlZCBjaGFpbiBpcyBzdXBwb3J0ZWQgYnkgYSBmYXVjZXQgYW5kIGlzIGEgdGVzdCBuZXR3b3JrLlxuICAgKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAqL1xuICBmdW5kVmlhRmF1Y2V0KCkge31cbn1cbiIsImV4cG9ydCBjb25zdCBzbWFydFdhbGxldEZhY3RvcnlBYmkgPSBbXG4gIHtcbiAgICB0eXBlOiAnY29uc3RydWN0b3InLFxuICAgIGlucHV0czogW1xuICAgICAgeyBuYW1lOiAnaW1wbGVtZW50YXRpb25fJywgdHlwZTogJ2FkZHJlc3MnLCBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAncGF5YWJsZScsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG5hbWU6ICdjcmVhdGVBY2NvdW50JyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ293bmVycycsIHR5cGU6ICdieXRlc1tdJywgaW50ZXJuYWxUeXBlOiAnYnl0ZXNbXScgfSxcbiAgICAgIHsgbmFtZTogJ25vbmNlJywgdHlwZTogJ3VpbnQyNTYnLCBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyB9LFxuICAgIF0sXG4gICAgb3V0cHV0czogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnYWNjb3VudCcsXG4gICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiAnY29udHJhY3QgQ29pbmJhc2VTbWFydFdhbGxldCcsXG4gICAgICB9LFxuICAgIF0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAncGF5YWJsZScsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG5hbWU6ICdnZXRBZGRyZXNzJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHsgbmFtZTogJ293bmVycycsIHR5cGU6ICdieXRlc1tdJywgaW50ZXJuYWxUeXBlOiAnYnl0ZXNbXScgfSxcbiAgICAgIHsgbmFtZTogJ25vbmNlJywgdHlwZTogJ3VpbnQyNTYnLCBpbnRlcm5hbFR5cGU6ICd1aW50MjU2JyB9LFxuICAgIF0sXG4gICAgb3V0cHV0czogW3sgbmFtZTogJycsIHR5cGU6ICdhZGRyZXNzJywgaW50ZXJuYWxUeXBlOiAnYWRkcmVzcycgfV0sXG4gICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG5hbWU6ICdpbXBsZW1lbnRhdGlvbicsXG4gICAgaW5wdXRzOiBbXSxcbiAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ2FkZHJlc3MnLCBpbnRlcm5hbFR5cGU6ICdhZGRyZXNzJyB9XSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgfSxcbiAge1xuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgbmFtZTogJ2luaXRDb2RlSGFzaCcsXG4gICAgaW5wdXRzOiBbXSxcbiAgICBvdXRwdXRzOiBbeyBuYW1lOiAnJywgdHlwZTogJ2J5dGVzMzInLCBpbnRlcm5hbFR5cGU6ICdieXRlczMyJyB9XSxcbiAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAgfSxcbiAge1xuICAgIHR5cGU6ICdldmVudCcsXG4gICAgbmFtZTogJ0FjY291bnRDcmVhdGVkJyxcbiAgICBpbnB1dHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2FjY291bnQnLFxuICAgICAgICB0eXBlOiAnYWRkcmVzcycsXG4gICAgICAgIGluZGV4ZWQ6IHRydWUsXG4gICAgICAgIGludGVybmFsVHlwZTogJ2FkZHJlc3MnLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ293bmVycycsXG4gICAgICAgIHR5cGU6ICdieXRlc1tdJyxcbiAgICAgICAgaW5kZXhlZDogZmFsc2UsXG4gICAgICAgIGludGVybmFsVHlwZTogJ2J5dGVzW10nLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ25vbmNlJyxcbiAgICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICAgICAgICBpbmRleGVkOiBmYWxzZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiAndWludDI1NicsXG4gICAgICB9LFxuICAgIF0sXG4gICAgYW5vbnltb3VzOiBmYWxzZSxcbiAgfSxcbiAgeyB0eXBlOiAnZXJyb3InLCBuYW1lOiAnSW1wbGVtZW50YXRpb25VbmRlcGxveWVkJywgaW5wdXRzOiBbXSB9LFxuICB7IHR5cGU6ICdlcnJvcicsIG5hbWU6ICdPd25lclJlcXVpcmVkJywgaW5wdXRzOiBbXSB9LFxuXSBhcyBjb25zdFxuIiwiZXhwb3J0IGNvbnN0IHNtYXJ0V2FsbGV0RmFjdG9yeUFkZHJlc3MgPVxuICBcIjB4QkE1RUQxMTBlRkRCYTNEMDA1YmZDODgyZDc1MzU4QUNCYkI4NTg0MlwiO1xuIiwiaW1wb3J0IHR5cGUgeyBBZGRyZXNzLCBIYXNoLCBMb2NhbEFjY291bnQgfSBmcm9tIFwidmllbVwiO1xuaW1wb3J0IHsgZW5jb2RlRnVuY3Rpb25EYXRhLCBlcmMyMEFiaSwgcGFkIH0gZnJvbSBcInZpZW1cIjtcbmltcG9ydCB0eXBlIHsgV2ViQXV0aG5BY2NvdW50IH0gZnJvbSBcInZpZW0vYWNjb3VudC1hYnN0cmFjdGlvblwiO1xuaW1wb3J0IHsgdG9Db2luYmFzZVNtYXJ0QWNjb3VudCB9IGZyb20gXCJ2aWVtL2FjY291bnQtYWJzdHJhY3Rpb25cIjtcbmltcG9ydCB7IHVuaWNoYWluIH0gZnJvbSBcInZpZW0vY2hhaW5zXCI7XG5cbmltcG9ydCB7IHNtYXJ0V2FsbGV0RmFjdG9yeUFiaSB9IGZyb20gXCJAL2FiaXMvc21hcnRXYWxsZXRGYWN0b3J5XCI7XG5pbXBvcnQgeyBzbWFydFdhbGxldEZhY3RvcnlBZGRyZXNzIH0gZnJvbSBcIkAvY29uc3RhbnRzL2FkZHJlc3Nlc1wiO1xuaW1wb3J0IHR5cGUgeyBTdXBwb3J0ZWRDaGFpbklkIH0gZnJvbSBcIkAvY29uc3RhbnRzL2NoYWluc1wiO1xuaW1wb3J0IHR5cGUgeyBDaGFpbk1hbmFnZXIgfSBmcm9tIFwiQC90b29scy9DaGFpbk1hbmFnZXJcIjtcbmltcG9ydCB7IGZldGNoRVJDMjBCYWxhbmNlLCBmZXRjaEVUSEJhbGFuY2UgfSBmcm9tIFwiQC90b29scy9Ub2tlbkJhbGFuY2VcIjtcbmltcG9ydCB7IFNVUFBPUlRFRF9UT0tFTlMgfSBmcm9tIFwiQC9jb25zdGFudHMvdG9rZW5zXCI7XG4vLyBpbXBvcnQgdHlwZSB7XG4vLyAgIExlbmRPcHRpb25zLFxuLy8gICBMZW5kUHJvdmlkZXIsXG4vLyAgIExlbmRUcmFuc2FjdGlvbixcbi8vICAgVHJhbnNhY3Rpb25EYXRhLFxuLy8gfSBmcm9tIFwiQC90eXBlcy9sZW5kLmpzXCI7XG5pbXBvcnQgdHlwZSB7IFRva2VuQmFsYW5jZSB9IGZyb20gXCJAL3R5cGVzL3Rva2VuXCI7XG5pbXBvcnQge1xuICB0eXBlIEFzc2V0SWRlbnRpZmllcixcbiAgcGFyc2VBc3NldEFtb3VudCxcbiAgcGFyc2VMZW5kUGFyYW1zLFxuICByZXNvbHZlQXNzZXQsXG59IGZyb20gXCJAL3V0aWxzL2Fzc2V0c1wiO1xuaW1wb3J0IHsgU21hcnRXYWxsZXQgfSBmcm9tIFwiQC93YWxsZXQvYmFzZS93YWxsZXRzL1NtYXJ0V2FsbGV0XCI7XG5pbXBvcnQgdHlwZSB7IFRyYW5zYWN0aW9uRGF0YSB9IGZyb20gXCJAL3R5cGVzL3RyYW5zYWN0aW9uXCI7XG5cbi8qKlxuICogU21hcnQgV2FsbGV0IEltcGxlbWVudGF0aW9uXG4gKiBAZGVzY3JpcHRpb24gRVJDLTQzMzcgY29tcGF0aWJsZSBzbWFydCB3YWxsZXQgdGhhdCB1c2VzIENvaW5iYXNlIFNtYXJ0IEFjY291bnQgKGh0dHBzOi8vZ2l0aHViLmNvbS9jb2luYmFzZS9zbWFydC13YWxsZXQvYmxvYi9tYWluL3NyYy9Db2luYmFzZVNtYXJ0V2FsbGV0LnNvbCkuXG4gKiBTdXBwb3J0cyBtdWx0aS1vd25lciB3YWxsZXRzLCBnYXNsZXNzIHRyYW5zYWN0aW9ucyB2aWEgcGF5bWFzdGVycywgYW5kIGNyb3NzLWNoYWluIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0U21hcnRXYWxsZXQgZXh0ZW5kcyBTbWFydFdhbGxldCB7XG4gIC8qKiBBcnJheSBvZiB3YWxsZXQgb3duZXJzIChFdGhlcmV1bSBhZGRyZXNzZXMgb3IgV2ViQXV0aG4gcHVibGljIGtleXMpICovXG4gIHByaXZhdGUgb3duZXJzOiBBcnJheTxBZGRyZXNzIHwgV2ViQXV0aG5BY2NvdW50PjtcbiAgLyoqIExvY2FsIGFjY291bnQgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMgYW5kIFVzZXJPcGVyYXRpb25zICovXG4gIHByaXZhdGUgX3NpZ25lcjogTG9jYWxBY2NvdW50O1xuICAvKiogSW5kZXggb2YgdGhlIHNpZ25lciBpbiB0aGUgb3duZXJzIGFycmF5IChkZWZhdWx0cyB0byAwIGlmIG5vdCBzcGVjaWZpZWQpICovXG4gIHByaXZhdGUgc2lnbmVyT3duZXJJbmRleD86IG51bWJlcjtcbiAgLyoqIEtub3duIGRlcGxveW1lbnQgYWRkcmVzcyBvZiB0aGUgd2FsbGV0IChpZiBhbHJlYWR5IGRlcGxveWVkKSAqL1xuICBwcml2YXRlIGRlcGxveW1lbnRBZGRyZXNzPzogQWRkcmVzcztcbiAgLyoqIFByb3ZpZGVyIGZvciBsZW5kaW5nIG1hcmtldCBvcGVyYXRpb25zICovXG4gIC8vICAgcHJpdmF0ZSBsZW5kUHJvdmlkZXI6IExlbmRQcm92aWRlcjtcbiAgLyoqIE1hbmFnZXMgc3VwcG9ydGVkIGJsb2NrY2hhaW4gbmV0d29ya3MgYW5kIFJQQyBjbGllbnRzICovXG4gIHByaXZhdGUgY2hhaW5NYW5hZ2VyOiBDaGFpbk1hbmFnZXI7XG4gIC8qKiBOb25jZSB1c2VkIGZvciBkZXRlcm1pbmlzdGljIGFkZHJlc3MgZ2VuZXJhdGlvbiAoZGVmYXVsdHMgdG8gMCkgKi9cbiAgcHJpdmF0ZSBub25jZT86IGJpZ2ludDtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgU21hcnQgV2FsbGV0IGluc3RhbmNlXG4gICAqIEBwYXJhbSBvd25lcnMgLSBBcnJheSBvZiB3YWxsZXQgb3duZXJzIChhZGRyZXNzZXMgb3IgV2ViQXV0aG4gYWNjb3VudHMpXG4gICAqIEBwYXJhbSBzaWduZXIgLSBMb2NhbCBhY2NvdW50IGZvciBzaWduaW5nIHRyYW5zYWN0aW9uc1xuICAgKiBAcGFyYW0gY2hhaW5NYW5hZ2VyIC0gTmV0d29yayBtYW5hZ2VtZW50IHNlcnZpY2Vcbi8vICAgICogQHBhcmFtIGxlbmRQcm92aWRlciAtIExlbmRpbmcgb3BlcmF0aW9ucyBwcm92aWRlclxuICAgKiBAcGFyYW0gYnVuZGxlclVybCAtIEVSQy00MzM3IGJ1bmRsZXIgc2VydmljZSBVUkxcbiAgICogQHBhcmFtIGRlcGxveW1lbnRBZGRyZXNzIC0gS25vd24gd2FsbGV0IGFkZHJlc3MgKGlmIGFscmVhZHkgZGVwbG95ZWQpXG4gICAqIEBwYXJhbSBvd25lckluZGV4IC0gSW5kZXggb2Ygc2lnbmVyIGluIG93bmVycyBhcnJheVxuICAgKiBAcGFyYW0gbm9uY2UgLSBOb25jZSBmb3IgYWRkcmVzcyBnZW5lcmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBvd25lcnM6IEFycmF5PEFkZHJlc3MgfCBXZWJBdXRobkFjY291bnQ+LFxuICAgIHNpZ25lcjogTG9jYWxBY2NvdW50LFxuICAgIGNoYWluTWFuYWdlcjogQ2hhaW5NYW5hZ2VyLFxuICAgIC8vIGxlbmRQcm92aWRlcjogTGVuZFByb3ZpZGVyLFxuICAgIGRlcGxveW1lbnRBZGRyZXNzPzogQWRkcmVzcyxcbiAgICBzaWduZXJPd25lckluZGV4PzogbnVtYmVyLFxuICAgIG5vbmNlPzogYmlnaW50XG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vd25lcnMgPSBvd25lcnM7XG4gICAgdGhpcy5fc2lnbmVyID0gc2lnbmVyO1xuICAgIHRoaXMuc2lnbmVyT3duZXJJbmRleCA9IHNpZ25lck93bmVySW5kZXg7XG4gICAgdGhpcy5kZXBsb3ltZW50QWRkcmVzcyA9IGRlcGxveW1lbnRBZGRyZXNzO1xuICAgIHRoaXMuY2hhaW5NYW5hZ2VyID0gY2hhaW5NYW5hZ2VyO1xuICAgIC8vIHRoaXMubGVuZFByb3ZpZGVyID0gbGVuZFByb3ZpZGVyO1xuICAgIHRoaXMubm9uY2UgPSBub25jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNpZ25lciBhY2NvdW50IGZvciB0aGlzIHNtYXJ0IHdhbGxldFxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgTG9jYWxBY2NvdW50IGluc3RhbmNlIHVzZWQgZm9yIHNpZ25pbmcgdHJhbnNhY3Rpb25zIGFuZCBVc2VyT3BlcmF0aW9ucy5cbiAgICogVGhpcyBzaWduZXIgaXMgdXNlZCB0byBhdXRob3JpemUgb3BlcmF0aW9ucyBvbiBiZWhhbGYgb2YgdGhlIHNtYXJ0IHdhbGxldC5cbiAgICogQHJldHVybnMgVGhlIExvY2FsQWNjb3VudCBzaWduZXIgY29uZmlndXJlZCBmb3IgdGhpcyBzbWFydCB3YWxsZXRcbiAgICovXG4gIGdldCBzaWduZXIoKTogTG9jYWxBY2NvdW50IHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc21hcnQgd2FsbGV0IGFkZHJlc3NcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGRlcGxveW1lbnQgYWRkcmVzcyBpZiBrbm93biwgb3RoZXJ3aXNlIGNhbGN1bGF0ZXMgdGhlIGRldGVybWluaXN0aWNcbiAgICogYWRkcmVzcyB1c2luZyBDUkVBVEUyIGJhc2VkIG9uIG93bmVycyBhbmQgbm9uY2UuXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB3YWxsZXQgYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgZ2V0QWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5kZXBsb3ltZW50QWRkcmVzcykgcmV0dXJuIHRoaXMuZGVwbG95bWVudEFkZHJlc3M7XG5cbiAgICBjb25zdCBvd25lcnNfYnl0ZXMgPSB0aGlzLm93bmVycy5tYXAoKG93bmVyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG93bmVyID09PSBcInN0cmluZ1wiKSByZXR1cm4gcGFkKG93bmVyKTtcbiAgICAgIGlmIChvd25lci50eXBlID09PSBcIndlYkF1dGhuXCIpIHJldHVybiBvd25lci5wdWJsaWNLZXk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG93bmVyIHR5cGVcIik7XG4gICAgfSk7XG5cbiAgICAvLyBGYWN0b3J5IGlzIHRoZSBzYW1lIGFjY3Jvc3MgYWxsIGNoYWlucywgc28gd2UgY2FuIHVzZSB0aGUgZmlyc3QgY2hhaW4gdG8gZ2V0IHRoZSB3YWxsZXQgYWRkcmVzc1xuICAgIGNvbnN0IHN1cHBvcnRlZENoYWlucyA9IHRoaXMuY2hhaW5NYW5hZ2VyLmdldFN1cHBvcnRlZENoYWlucygpO1xuICAgIGlmICghc3VwcG9ydGVkQ2hhaW5zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VwcG9ydGVkIGNoYWlucyBjb25maWd1cmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNDbGllbnQgPSB0aGlzLmNoYWluTWFuYWdlci5nZXRQdWJsaWNDbGllbnQoc3VwcG9ydGVkQ2hhaW5zWzBdISk7XG4gICAgY29uc3Qgc21hcnRXYWxsZXRBZGRyZXNzID0gYXdhaXQgcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgICBhYmk6IHNtYXJ0V2FsbGV0RmFjdG9yeUFiaSxcbiAgICAgIGFkZHJlc3M6IHNtYXJ0V2FsbGV0RmFjdG9yeUFkZHJlc3MsXG4gICAgICBmdW5jdGlvbk5hbWU6IFwiZ2V0QWRkcmVzc1wiLFxuICAgICAgYXJnczogW293bmVyc19ieXRlcywgdGhpcy5ub25jZSB8fCAwbl0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHNtYXJ0V2FsbGV0QWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBDb2luYmFzZSBTbWFydCBBY2NvdW50IGluc3RhbmNlXG4gICAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0cyB0aGlzIHdhbGxldCBpbnRvIGEgdmllbS1jb21wYXRpYmxlIHNtYXJ0IGFjY291bnQgZm9yIEVSQy00MzM3IG9wZXJhdGlvbnMuXG4gICAqIEBwYXJhbSBjaGFpbklkIC0gVGFyZ2V0IGJsb2NrY2hhaW4gbmV0d29yayBJRFxuICAgKiBAcmV0dXJucyBDb2luYmFzZSBTbWFydCBBY2NvdW50IGluc3RhbmNlIGNvbmZpZ3VyZWQgZm9yIHRoZSBzcGVjaWZpZWQgY2hhaW5cbiAgICovXG4gIGFzeW5jIGdldENvaW5iYXNlU21hcnRBY2NvdW50KFxuICAgIGNoYWluSWQ6IFN1cHBvcnRlZENoYWluSWRcbiAgKTogUmV0dXJuVHlwZTx0eXBlb2YgdG9Db2luYmFzZVNtYXJ0QWNjb3VudD4ge1xuICAgIHJldHVybiB0b0NvaW5iYXNlU21hcnRBY2NvdW50KHtcbiAgICAgIGFkZHJlc3M6IHRoaXMuZGVwbG95bWVudEFkZHJlc3MsXG4gICAgICBvd25lckluZGV4OiB0aGlzLnNpZ25lck93bmVySW5kZXgsXG4gICAgICBjbGllbnQ6IHRoaXMuY2hhaW5NYW5hZ2VyLmdldFB1YmxpY0NsaWVudChjaGFpbklkKSxcbiAgICAgIG93bmVyczogW3RoaXMuc2lnbmVyXSxcbiAgICAgIG5vbmNlOiB0aGlzLm5vbmNlLFxuICAgICAgdmVyc2lvbjogXCIxLjFcIixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYXNzZXQgYmFsYW5jZXMgYWNyb3NzIGFsbCBzdXBwb3J0ZWQgY2hhaW5zXG4gICAqIEBkZXNjcmlwdGlvbiBGZXRjaGVzIEVUSCBhbmQgRVJDMjAgdG9rZW4gYmFsYW5jZXMgZm9yIHRoaXMgd2FsbGV0IGFjcm9zcyBhbGwgc3VwcG9ydGVkIG5ldHdvcmtzLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiB0b2tlbiBiYWxhbmNlcyB3aXRoIGNoYWluIGJyZWFrZG93blxuICAgKi9cbiAgYXN5bmMgZ2V0QmFsYW5jZSgpOiBQcm9taXNlPFRva2VuQmFsYW5jZVtdPiB7XG4gICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgIGNvbnN0IHRva2VuQmFsYW5jZVByb21pc2VzID0gT2JqZWN0LnZhbHVlcyhTVVBQT1JURURfVE9LRU5TKS5tYXAoXG4gICAgICBhc3luYyAodG9rZW4pID0+IHtcbiAgICAgICAgcmV0dXJuIGZldGNoRVJDMjBCYWxhbmNlKHRoaXMuY2hhaW5NYW5hZ2VyLCBhZGRyZXNzLCB0b2tlbik7XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25zdCBldGhCYWxhbmNlUHJvbWlzZSA9IGZldGNoRVRIQmFsYW5jZSh0aGlzLmNoYWluTWFuYWdlciwgYWRkcmVzcyk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2V0aEJhbGFuY2VQcm9taXNlLCAuLi50b2tlbkJhbGFuY2VQcm9taXNlc10pO1xuICB9XG5cbiAgLy8gICAvKipcbiAgLy8gICAgKiBMZW5kIGFzc2V0cyB0byBhIGxlbmRpbmcgbWFya2V0XG4gIC8vICAgICogQGRlc2NyaXB0aW9uIExlbmRzIGFzc2V0cyB1c2luZyB0aGUgY29uZmlndXJlZCBsZW5kaW5nIHByb3ZpZGVyIHdpdGggaHVtYW4tcmVhZGFibGUgYW1vdW50c1xuICAvLyAgICAqIEBwYXJhbSBhbW91bnQgLSBIdW1hbi1yZWFkYWJsZSBhbW91bnQgdG8gbGVuZCAoZS5nLiAxLjUpXG4gIC8vICAgICogQHBhcmFtIGFzc2V0IC0gQXNzZXQgc3ltYm9sIChlLmcuICd1c2RjJykgb3IgdG9rZW4gYWRkcmVzc1xuICAvLyAgICAqIEBwYXJhbSBtYXJrZXRJZCAtIE9wdGlvbmFsIHNwZWNpZmljIG1hcmtldCBJRCBvciB2YXVsdCBuYW1lXG4gIC8vICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBsZW5kaW5nIGNvbmZpZ3VyYXRpb25cbiAgLy8gICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBsZW5kaW5nIHRyYW5zYWN0aW9uIGRldGFpbHNcbiAgLy8gICAgKiBAdGhyb3dzIEVycm9yIGlmIG5vIGxlbmRpbmcgcHJvdmlkZXIgaXMgY29uZmlndXJlZFxuICAvLyAgICAqL1xuICAvLyAgIGFzeW5jIGxlbmQoXG4gIC8vICAgICBhbW91bnQ6IG51bWJlcixcbiAgLy8gICAgIGFzc2V0OiBBc3NldElkZW50aWZpZXIsXG4gIC8vICAgICBjaGFpbklkOiBTdXBwb3J0ZWRDaGFpbklkLFxuICAvLyAgICAgbWFya2V0SWQ/OiBzdHJpbmcsXG4gIC8vICAgICBvcHRpb25zPzogTGVuZE9wdGlvbnNcbiAgLy8gICApOiBQcm9taXNlPExlbmRUcmFuc2FjdGlvbj4ge1xuICAvLyAgICAgLy8gUGFyc2UgaHVtYW4tcmVhZGFibGUgaW5wdXRzXG4gIC8vICAgICBjb25zdCB7IGFtb3VudDogcGFyc2VkQW1vdW50LCBhc3NldDogcmVzb2x2ZWRBc3NldCB9ID0gcGFyc2VMZW5kUGFyYW1zKFxuICAvLyAgICAgICBhbW91bnQsXG4gIC8vICAgICAgIGFzc2V0LFxuICAvLyAgICAgICBjaGFpbklkXG4gIC8vICAgICApO1xuICAvLyAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzcygpO1xuXG4gIC8vICAgICAvLyBTZXQgcmVjZWl2ZXIgdG8gd2FsbGV0IGFkZHJlc3MgaWYgbm90IHNwZWNpZmllZFxuICAvLyAgICAgY29uc3QgbGVuZE9wdGlvbnM6IExlbmRPcHRpb25zID0ge1xuICAvLyAgICAgICAuLi5vcHRpb25zLFxuICAvLyAgICAgICByZWNlaXZlcjogb3B0aW9ucz8ucmVjZWl2ZXIgfHwgYWRkcmVzcyxcbiAgLy8gICAgIH07XG5cbiAgLy8gICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubGVuZFByb3ZpZGVyLmRlcG9zaXQoXG4gIC8vICAgICAgIHJlc29sdmVkQXNzZXQuYWRkcmVzcyxcbiAgLy8gICAgICAgcGFyc2VkQW1vdW50LFxuICAvLyAgICAgICBtYXJrZXRJZCxcbiAgLy8gICAgICAgbGVuZE9wdGlvbnNcbiAgLy8gICAgICk7XG5cbiAgLy8gICAgIHJldHVybiByZXN1bHQ7XG4gIC8vICAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdmlhIEVSQy00MzM3XG4gICAqIEBkZXNjcmlwdGlvbiBFeGVjdXRlcyBhIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBzbWFydCB3YWxsZXQgd2l0aCBhdXRvbWF0aWMgZ2FzIHNwb25zb3JzaGlwLlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gaXMgc2VudCBhcyBhIFVzZXJPcGVyYXRpb24gdGhyb3VnaCB0aGUgYnVuZGxlciBzZXJ2aWNlLlxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25EYXRhIC0gVHJhbnNhY3Rpb24gZGV0YWlscyAodG8sIHZhbHVlLCBkYXRhKVxuICAgKiBAcGFyYW0gY2hhaW5JZCAtIFRhcmdldCBibG9ja2NoYWluIG5ldHdvcmsgSURcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gVXNlck9wZXJhdGlvbiBoYXNoXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdHJhbnNhY3Rpb24gZmFpbHMgb3IgdmFsaWRhdGlvbiBlcnJvcnMgb2NjdXJcbiAgICovXG4gIGFzeW5jIHNlbmQoXG4gICAgdHJhbnNhY3Rpb25EYXRhOiBUcmFuc2FjdGlvbkRhdGEsXG4gICAgY2hhaW5JZDogU3VwcG9ydGVkQ2hhaW5JZFxuICApOiBQcm9taXNlPEhhc2g+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWNjb3VudCA9IGF3YWl0IHRoaXMuZ2V0Q29pbmJhc2VTbWFydEFjY291bnQoY2hhaW5JZCk7XG4gICAgICBjb25zdCBidW5kbGVyQ2xpZW50ID0gdGhpcy5jaGFpbk1hbmFnZXIuZ2V0QnVuZGxlckNsaWVudChcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgYWNjb3VudFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGNhbGxzID0gW3RyYW5zYWN0aW9uRGF0YV07XG4gICAgICBjb25zdCBoYXNoID0gYXdhaXQgYnVuZGxlckNsaWVudC5zZW5kVXNlck9wZXJhdGlvbih7XG4gICAgICAgIGFjY291bnQsXG4gICAgICAgIGNhbGxzLFxuICAgICAgICBwYXltYXN0ZXI6IHRydWUsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IGJ1bmRsZXJDbGllbnQud2FpdEZvclVzZXJPcGVyYXRpb25SZWNlaXB0KHtcbiAgICAgICAgaGFzaCxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHNlbmQgdHJhbnNhY3Rpb246ICR7XG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIlxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnVuZCBhIHdhbGxldCB3aXRoIFVTREMgdXNpbmcgb24tcmFtcCBzZXJ2aWNlXG4gICAqIEBkZXNjcmlwdGlvbiBGdW5kcyB0aGUgY3VycmVudCB3YWxsZXQgd2l0aCBVU0RDIHVzaW5nIG9uLXJhbXAgc2VydmljZVxuICAgKiBAcmV0dXJucyBSZXR1cm4gVVJMIHRvIHRoZSBvbi1yYW1wIHNlcnZpY2VcbiAgICovXG4gIGZ1bmRVU0RDKCkge31cblxuICAvKipcbiAgICogU2VuZCB0b2tlbnMgdG8gYW5vdGhlciBhZGRyZXNzXG4gICAqIEBkZXNjcmlwdGlvbiBTZW5kcyBFVEggb3IgRVJDMjAgdG9rZW5zIHRvIGEgcmVjaXBpZW50IGFkZHJlc3NcbiAgICogQHBhcmFtIGFtb3VudCAtIEh1bWFuLXJlYWRhYmxlIGFtb3VudCB0byBzZW5kIChlLmcuIDEuNSlcbiAgICogQHBhcmFtIGFzc2V0IC0gQXNzZXQgc3ltYm9sIChlLmcuICd1c2RjJywgJ2V0aCcpIG9yIHRva2VuIGFkZHJlc3NcbiAgICogQHBhcmFtIHJlY2lwaWVudEFkZHJlc3MgLSBBZGRyZXNzIHRvIHNlbmQgdG9cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJhbnNhY3Rpb24gZGF0YVxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHdhbGxldCBpcyBub3QgaW5pdGlhbGl6ZWQgb3IgYXNzZXQgaXMgbm90IHN1cHBvcnRlZFxuICAgKi9cbiAgYXN5bmMgc2VuZFRva2VucyhcbiAgICBhbW91bnQ6IG51bWJlcixcbiAgICBhc3NldDogQXNzZXRJZGVudGlmaWVyLFxuICAgIHJlY2lwaWVudEFkZHJlc3M6IEFkZHJlc3NcbiAgKTogUHJvbWlzZTxUcmFuc2FjdGlvbkRhdGE+IHtcbiAgICBpZiAoIXJlY2lwaWVudEFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY2lwaWVudCBhZGRyZXNzIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGFtb3VudFxuICAgIGlmIChhbW91bnQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogR2V0IGFjdHVhbCBjaGFpbiBJRCBmcm9tIHdhbGxldCBjb250ZXh0LCBmb3Igbm93IHVzaW5nIFVuaWNoYWluXG4gICAgY29uc3QgY2hhaW5JZCA9IHVuaWNoYWluLmlkO1xuXG4gICAgLy8gSGFuZGxlIEVUSCB0cmFuc2ZlcnNcbiAgICBpZiAoYXNzZXQudG9Mb3dlckNhc2UoKSA9PT0gXCJldGhcIikge1xuICAgICAgY29uc3QgcGFyc2VkQW1vdW50ID0gcGFyc2VBc3NldEFtb3VudChhbW91bnQsIDE4KTsgLy8gRVRIIGhhcyAxOCBkZWNpbWFsc1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0bzogcmVjaXBpZW50QWRkcmVzcyxcbiAgICAgICAgdmFsdWU6IHBhcnNlZEFtb3VudCxcbiAgICAgICAgZGF0YTogXCIweFwiLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgRVJDMjAgdG9rZW4gdHJhbnNmZXJzXG4gICAgY29uc3QgcmVzb2x2ZWRBc3NldCA9IHJlc29sdmVBc3NldChhc3NldCwgY2hhaW5JZCk7XG4gICAgY29uc3QgcGFyc2VkQW1vdW50ID0gcGFyc2VBc3NldEFtb3VudChhbW91bnQsIHJlc29sdmVkQXNzZXQuZGVjaW1hbHMpO1xuXG4gICAgLy8gRW5jb2RlIEVSQzIwIHRyYW5zZmVyIGZ1bmN0aW9uIGNhbGxcbiAgICBjb25zdCB0cmFuc2ZlckRhdGEgPSBlbmNvZGVGdW5jdGlvbkRhdGEoe1xuICAgICAgYWJpOiBlcmMyMEFiaSxcbiAgICAgIGZ1bmN0aW9uTmFtZTogXCJ0cmFuc2ZlclwiLFxuICAgICAgYXJnczogW3JlY2lwaWVudEFkZHJlc3MsIHBhcnNlZEFtb3VudF0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG86IHJlc29sdmVkQXNzZXQuYWRkcmVzcyxcbiAgICAgIHZhbHVlOiAwbixcbiAgICAgIGRhdGE6IHRyYW5zZmVyRGF0YSxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IEFkZHJlc3MgfSBmcm9tIFwidmllbVwiO1xuaW1wb3J0IHsgZXJjMjBBYmksIGZvcm1hdEV0aGVyLCBmb3JtYXRVbml0cyB9IGZyb20gXCJ2aWVtXCI7XG5cbmltcG9ydCB0eXBlIHsgU3VwcG9ydGVkQ2hhaW5JZCB9IGZyb20gXCJAL2NvbnN0YW50cy9jaGFpbnNcIjtcbmltcG9ydCB0eXBlIHsgQ2hhaW5NYW5hZ2VyIH0gZnJvbSBcIkAvdG9vbHMvQ2hhaW5NYW5hZ2VyXCI7XG5pbXBvcnQgeyBnZXRUb2tlbkFkZHJlc3MsIHR5cGUgVG9rZW5JbmZvIH0gZnJvbSBcIkAvdXRpbHMvdG9rZW5zXCI7XG5pbXBvcnQgdHlwZSB7IFRva2VuQmFsYW5jZSB9IGZyb20gXCJAL3R5cGVzL3Rva2VuLmpzXCI7XG5cbi8qKlxuICogRmV0Y2ggRVRIIGJhbGFuY2UgYWNyb3NzIGFsbCBzdXBwb3J0ZWQgY2hhaW5zXG4gKiBAcGFyYW0gY2hhaW5NYW5hZ2VyIC0gVGhlIGNoYWluIG1hbmFnZXJcbiAqIEBwYXJhbSB3YWxsZXRBZGRyZXNzIC0gVGhlIHdhbGxldCBhZGRyZXNzXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBFVEggYmFsYW5jZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoRVRIQmFsYW5jZShcbiAgY2hhaW5NYW5hZ2VyOiBDaGFpbk1hbmFnZXIsXG4gIHdhbGxldEFkZHJlc3M6IEFkZHJlc3Ncbik6IFByb21pc2U8VG9rZW5CYWxhbmNlPiB7XG4gIGNvbnN0IHN1cHBvcnRlZENoYWlucyA9IGNoYWluTWFuYWdlci5nZXRTdXBwb3J0ZWRDaGFpbnMoKTtcbiAgY29uc3QgY2hhaW5CYWxhbmNlUHJvbWlzZXMgPSBzdXBwb3J0ZWRDaGFpbnMubWFwKGFzeW5jIChjaGFpbklkKSA9PiB7XG4gICAgY29uc3QgcHVibGljQ2xpZW50ID0gY2hhaW5NYW5hZ2VyLmdldFB1YmxpY0NsaWVudChjaGFpbklkKTtcbiAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgcHVibGljQ2xpZW50LmdldEJhbGFuY2Uoe1xuICAgICAgYWRkcmVzczogd2FsbGV0QWRkcmVzcyxcbiAgICB9KTtcbiAgICByZXR1cm4geyBjaGFpbklkLCBiYWxhbmNlLCBmb3JtYXR0ZWRCYWxhbmNlOiBmb3JtYXRFdGhlcihiYWxhbmNlKSB9O1xuICB9KTtcbiAgY29uc3QgY2hhaW5CYWxhbmNlcyA9IGF3YWl0IFByb21pc2UuYWxsKGNoYWluQmFsYW5jZVByb21pc2VzKTtcbiAgY29uc3QgdG90YWxCYWxhbmNlID0gY2hhaW5CYWxhbmNlcy5yZWR1Y2UoXG4gICAgKHRvdGFsLCB7IGJhbGFuY2UgfSkgPT4gdG90YWwgKyBiYWxhbmNlLFxuICAgIDBuXG4gICk7XG4gIHJldHVybiB7XG4gICAgc3ltYm9sOiBcIkVUSFwiLFxuICAgIHRvdGFsQmFsYW5jZSxcbiAgICB0b3RhbEZvcm1hdHRlZEJhbGFuY2U6IGZvcm1hdEV0aGVyKHRvdGFsQmFsYW5jZSksXG4gICAgY2hhaW5CYWxhbmNlcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBGZXRjaCB0b3RhbCBiYWxhbmNlIGZvciB0aGlzIHRva2VuIGFjcm9zcyBhbGwgc3VwcG9ydGVkIGNoYWluc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hFUkMyMEJhbGFuY2UoXG4gIGNoYWluTWFuYWdlcjogQ2hhaW5NYW5hZ2VyLFxuICB3YWxsZXRBZGRyZXNzOiBBZGRyZXNzLFxuICB0b2tlbjogVG9rZW5JbmZvXG4pOiBQcm9taXNlPFRva2VuQmFsYW5jZT4ge1xuICBjb25zdCBzdXBwb3J0ZWRDaGFpbnMgPSBjaGFpbk1hbmFnZXIuZ2V0U3VwcG9ydGVkQ2hhaW5zKCk7XG4gIGNvbnN0IGNoYWluc1dpdGhUb2tlbiA9IHN1cHBvcnRlZENoYWlucy5maWx0ZXIoKGNoYWluSWQpID0+XG4gICAgZ2V0VG9rZW5BZGRyZXNzKHRva2VuLnN5bWJvbCwgY2hhaW5JZClcbiAgKTtcblxuICBjb25zdCBjaGFpbkJhbGFuY2VQcm9taXNlcyA9IGNoYWluc1dpdGhUb2tlbi5tYXAoYXN5bmMgKGNoYWluSWQpID0+IHtcbiAgICBjb25zdCBiYWxhbmNlID0gYXdhaXQgZmV0Y2hFUkMyMEJhbGFuY2VGb3JDaGFpbihcbiAgICAgIHRva2VuLFxuICAgICAgY2hhaW5JZCxcbiAgICAgIHdhbGxldEFkZHJlc3MsXG4gICAgICBjaGFpbk1hbmFnZXJcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBjaGFpbklkLFxuICAgICAgYmFsYW5jZSxcbiAgICAgIGZvcm1hdHRlZEJhbGFuY2U6IGZvcm1hdFVuaXRzKGJhbGFuY2UsIHRva2VuLmRlY2ltYWxzKSxcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBjaGFpbkJhbGFuY2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoY2hhaW5CYWxhbmNlUHJvbWlzZXMpO1xuICBjb25zdCB0b3RhbEJhbGFuY2UgPSBjaGFpbkJhbGFuY2VzLnJlZHVjZShcbiAgICAodG90YWwsIHsgYmFsYW5jZSB9KSA9PiB0b3RhbCArIGJhbGFuY2UsXG4gICAgMG5cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIHN5bWJvbDogdG9rZW4uc3ltYm9sLFxuICAgIHRvdGFsQmFsYW5jZSxcbiAgICB0b3RhbEZvcm1hdHRlZEJhbGFuY2U6IGZvcm1hdFVuaXRzKHRvdGFsQmFsYW5jZSwgdG9rZW4uZGVjaW1hbHMpLFxuICAgIGNoYWluQmFsYW5jZXMsXG4gIH07XG59XG5cbi8qKlxuICogRmV0Y2ggYmFsYW5jZSBmb3IgdGhpcyB0b2tlbiBvbiBhIHNwZWNpZmljIGNoYWluXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRVJDMjBCYWxhbmNlRm9yQ2hhaW4oXG4gIHRva2VuOiBUb2tlbkluZm8sXG4gIGNoYWluSWQ6IFN1cHBvcnRlZENoYWluSWQsXG4gIHdhbGxldEFkZHJlc3M6IEFkZHJlc3MsXG4gIGNoYWluTWFuYWdlcjogQ2hhaW5NYW5hZ2VyXG4pOiBQcm9taXNlPGJpZ2ludD4ge1xuICBjb25zdCB0b2tlbkFkZHJlc3MgPSBnZXRUb2tlbkFkZHJlc3ModG9rZW4uc3ltYm9sLCBjaGFpbklkKTtcbiAgaWYgKCF0b2tlbkFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dG9rZW4uc3ltYm9sfSBub3Qgc3VwcG9ydGVkIG9uIGNoYWluICR7Y2hhaW5JZH1gKTtcbiAgfVxuXG4gIGNvbnN0IHB1YmxpY0NsaWVudCA9IGNoYWluTWFuYWdlci5nZXRQdWJsaWNDbGllbnQoY2hhaW5JZCk7XG5cbiAgLy8gSGFuZGxlIG5hdGl2ZSBFVEggYmFsYW5jZVxuICBpZiAodG9rZW4uc3ltYm9sID09PSBcIkVUSFwiKSB7XG4gICAgcmV0dXJuIHB1YmxpY0NsaWVudC5nZXRCYWxhbmNlKHtcbiAgICAgIGFkZHJlc3M6IHdhbGxldEFkZHJlc3MsXG4gICAgfSk7XG4gIH1cblxuICAvLyBIYW5kbGUgRVJDMjAgdG9rZW4gYmFsYW5jZVxuICByZXR1cm4gcHVibGljQ2xpZW50LnJlYWRDb250cmFjdCh7XG4gICAgYWRkcmVzczogdG9rZW5BZGRyZXNzLFxuICAgIGFiaTogZXJjMjBBYmksXG4gICAgZnVuY3Rpb25OYW1lOiBcImJhbGFuY2VPZlwiLFxuICAgIGFyZ3M6IFt3YWxsZXRBZGRyZXNzXSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgdHlwZSB7IFRva2VuSW5mbyB9IGZyb20gXCJAL3V0aWxzL3Rva2Vuc1wiO1xuaW1wb3J0IHsgbWFpbm5ldCwgdW5pY2hhaW4sIGJhc2UsIGJhc2VTZXBvbGlhLCBzZXBvbGlhIH0gZnJvbSBcInZpZW0vY2hhaW5zXCI7XG5cbmV4cG9ydCBjb25zdCBTVVBQT1JURURfVE9LRU5TOiBSZWNvcmQ8c3RyaW5nLCBUb2tlbkluZm8+ID0ge1xuICBFVEg6IHtcbiAgICBzeW1ib2w6IFwiRVRIXCIsXG4gICAgbmFtZTogXCJFdGhlcmV1bVwiLFxuICAgIGRlY2ltYWxzOiAxOCxcbiAgICBhZGRyZXNzZXM6IHtcbiAgICAgIFttYWlubmV0LmlkXTogXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgIFt1bmljaGFpbi5pZF06IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBbYmFzZS5pZF06IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICBbYmFzZVNlcG9saWEuaWRdOiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgICAgW3NlcG9saWEuaWRdOiBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiLFxuICAgIH0sXG4gIH0sXG4gIFVTREM6IHtcbiAgICBzeW1ib2w6IFwiVVNEQ1wiLFxuICAgIG5hbWU6IFwiVVNEQ1wiLFxuICAgIGRlY2ltYWxzOiA2LFxuICAgIGFkZHJlc3Nlczoge1xuICAgICAgW21haW5uZXQuaWRdOiBcIjB4YTBiODY5OTFjNjIxOGIzNmMxZDE5ZDRhMmU5ZWIwY2UzNjA2ZWI0OFwiLFxuICAgICAgW3VuaWNoYWluLmlkXTogXCIweDA3OGQ3ODJiNzYwNDc0YTM2MWRkYTBhZjM4MzkyOTBiMGVmNTdhZDZcIixcbiAgICAgIFtiYXNlU2Vwb2xpYS5pZF06IFwiMHgwMzZDYkQ1Mzg0MmM1NDI2NjM0ZTc5Mjk1NDFlQzIzMThmM2RDRjdlXCIsXG4gICAgICBbc2Vwb2xpYS5pZF06IFwiMHhmMDhBNTAxNzhkZmNEZTE4NTI0NjQwRUE2NjE4YTFmOTY1ODIxNzE1XCIsXG4gICAgfSxcbiAgfSxcbn07XG4iLCJpbXBvcnQgdHlwZSB7IEFkZHJlc3MgfSBmcm9tIFwidmllbVwiO1xuaW1wb3J0IHR5cGUgeyBTdXBwb3J0ZWRDaGFpbklkIH0gZnJvbSBcIkAvY29uc3RhbnRzL2NoYWluc1wiO1xuaW1wb3J0IHsgU1VQUE9SVEVEX1RPS0VOUyB9IGZyb20gXCJAL2NvbnN0YW50cy90b2tlbnNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBUb2tlbkluZm8ge1xuICBzeW1ib2w6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZWNpbWFsczogbnVtYmVyO1xuICBhZGRyZXNzZXM6IFBhcnRpYWw8UmVjb3JkPFN1cHBvcnRlZENoYWluSWQsIEFkZHJlc3M+PjsgLy8gY2hhaW5JZCAtPiBhZGRyZXNzXG59XG5cbi8qKlxuICogRmluZCB0b2tlbiBieSBhZGRyZXNzIGFuZCBjaGFpbiBJRFxuICogQHBhcmFtIGFkZHJlc3MgVG9rZW4gYWRkcmVzc1xuICogQHBhcmFtIGNoYWluSWQgQ2hhaW4gSURcbiAqIEByZXR1cm5zIFRva2VuIHN5bWJvbCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFRva2VuQnlBZGRyZXNzKFxuICBhZGRyZXNzOiBBZGRyZXNzLFxuICBjaGFpbklkOiBTdXBwb3J0ZWRDaGFpbklkXG4pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3Qgbm9ybWFsaXplZEFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG5cbiAgZm9yIChjb25zdCBbc3ltYm9sLCB0b2tlbl0gb2YgT2JqZWN0LmVudHJpZXMoU1VQUE9SVEVEX1RPS0VOUykpIHtcbiAgICBjb25zdCB0b2tlbkFkZHJlc3MgPSB0b2tlbi5hZGRyZXNzZXNbY2hhaW5JZF07XG4gICAgaWYgKHRva2VuQWRkcmVzcyAmJiB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gbm9ybWFsaXplZEFkZHJlc3MpIHtcbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2V0IHRva2VuIGFkZHJlc3MgZm9yIGEgc3BlY2lmaWMgY2hhaW5cbiAqIEBwYXJhbSBzeW1ib2wgVG9rZW4gc3ltYm9sXG4gKiBAcGFyYW0gY2hhaW5JZCBDaGFpbiBJRFxuICogQHJldHVybnMgVG9rZW4gYWRkcmVzcyBvciBudWxsIGlmIG5vdCBzdXBwb3J0ZWQgb24gdGhhdCBjaGFpblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5BZGRyZXNzKFxuICBzeW1ib2w6IHN0cmluZyxcbiAgY2hhaW5JZDogU3VwcG9ydGVkQ2hhaW5JZFxuKTogQWRkcmVzcyB8IG51bGwge1xuICBjb25zdCB0b2tlbiA9IFNVUFBPUlRFRF9UT0tFTlNbc3ltYm9sXTtcbiAgcmV0dXJuIHRva2VuPy5hZGRyZXNzZXNbY2hhaW5JZF0gfHwgbnVsbDtcbn1cbiIsImltcG9ydCB0eXBlIHsgQWRkcmVzcyB9IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgeyBwYXJzZVVuaXRzIH0gZnJvbSBcInZpZW1cIjtcblxuaW1wb3J0IHR5cGUgeyBTdXBwb3J0ZWRDaGFpbklkIH0gZnJvbSBcIkAvY29uc3RhbnRzL2NoYWluc1wiO1xuaW1wb3J0IHsgZ2V0VG9rZW5BZGRyZXNzIH0gZnJvbSBcIkAvdXRpbHMvdG9rZW5zXCI7XG5pbXBvcnQgeyBTVVBQT1JURURfVE9LRU5TIH0gZnJvbSBcIkAvY29uc3RhbnRzL3Rva2Vuc1wiO1xuXG4vKipcbiAqIEFzc2V0IGlkZW50aWZpZXIgLSBjYW4gYmUgYSBzeW1ib2wgKGxpa2UgJ3VzZGMnKSBvciBhZGRyZXNzXG4gKi9cbmV4cG9ydCB0eXBlIEFzc2V0SWRlbnRpZmllciA9IHN0cmluZyB8IEFkZHJlc3M7XG5cbi8qKlxuICogUmVzb2x2ZWQgYXNzZXQgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZEFzc2V0IHtcbiAgYWRkcmVzczogQWRkcmVzcztcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIGRlY2ltYWxzOiBudW1iZXI7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhc3NldCBpZGVudGlmaWVyIHRvIGFkZHJlc3MgYW5kIG1ldGFkYXRhXG4gKiBAcGFyYW0gYXNzZXQgLSBBc3NldCBzeW1ib2wgKGUuZy4gJ3VzZGMnKSBvciBhZGRyZXNzXG4gKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIElEIHRvIHJlc29sdmUgZm9yXG4gKiBAcmV0dXJucyBSZXNvbHZlZCBhc3NldCBpbmZvcm1hdGlvblxuICogQHRocm93cyBFcnJvciBpZiBhc3NldCBpcyBub3Qgc3VwcG9ydGVkIG9yIGZvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQXNzZXQoXG4gIGFzc2V0OiBBc3NldElkZW50aWZpZXIsXG4gIGNoYWluSWQ6IFN1cHBvcnRlZENoYWluSWRcbik6IFJlc29sdmVkQXNzZXQge1xuICAvLyBJZiBpdCdzIGFuIGFkZHJlc3MgKHN0YXJ0cyB3aXRoIDB4KSwgdmFsaWRhdGUgYW5kIGZpbmQgc3ltYm9sXG4gIGlmIChhc3NldC5zdGFydHNXaXRoKFwiMHhcIikpIHtcbiAgICBjb25zdCBhZGRyZXNzID0gYXNzZXQgYXMgQWRkcmVzcztcblxuICAgIC8vIFRyeSB0byBmaW5kIHRoZSBzeW1ib2wgZm9yIHRoaXMgYWRkcmVzc1xuICAgIGZvciAoY29uc3QgWywgdG9rZW5JbmZvXSBvZiBPYmplY3QuZW50cmllcyhTVVBQT1JURURfVE9LRU5TKSkge1xuICAgICAgY29uc3QgdG9rZW5BZGRyZXNzID0gdG9rZW5JbmZvLmFkZHJlc3Nlc1tjaGFpbklkXTtcbiAgICAgIGlmIChcbiAgICAgICAgdG9rZW5BZGRyZXNzICYmXG4gICAgICAgIHRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFkZHJlc3M6IHRva2VuQWRkcmVzcyxcbiAgICAgICAgICBzeW1ib2w6IHRva2VuSW5mby5zeW1ib2wsXG4gICAgICAgICAgZGVjaW1hbHM6IHRva2VuSW5mby5kZWNpbWFscyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgZm91bmQgaW4gc3VwcG9ydGVkIHRva2Vucywgd2UgY2FuJ3QgZGV0ZXJtaW5lIGRlY2ltYWxzXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFVua25vd24gYXNzZXQgYWRkcmVzczogJHthZGRyZXNzfS4gUGxlYXNlIHVzZSBhIHN1cHBvcnRlZCBhc3NldCBzeW1ib2wgbGlrZSAndXNkYycgb3IgYWRkIHRoZSB0b2tlbiB0byBTVVBQT1JURURfVE9LRU5TLmBcbiAgICApO1xuICB9XG5cbiAgLy8gSWYgaXQncyBhIHN5bWJvbCwgcmVzb2x2ZSB0byBhZGRyZXNzXG4gIGNvbnN0IG5vcm1hbGl6ZWRTeW1ib2wgPSBhc3NldC50b1VwcGVyQ2FzZSgpO1xuICBjb25zdCB0b2tlbkluZm8gPSBTVVBQT1JURURfVE9LRU5TW25vcm1hbGl6ZWRTeW1ib2xdO1xuXG4gIGlmICghdG9rZW5JbmZvKSB7XG4gICAgY29uc3QgYXZhaWxhYmxlU3ltYm9scyA9IE9iamVjdC5rZXlzKFNVUFBPUlRFRF9UT0tFTlMpLmpvaW4oXCIsIFwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgYXNzZXQgc3ltYm9sOiAke2Fzc2V0fS4gU3VwcG9ydGVkIGFzc2V0czogJHthdmFpbGFibGVTeW1ib2xzfWBcbiAgICApO1xuICB9XG5cbiAgY29uc3QgYWRkcmVzcyA9IGdldFRva2VuQWRkcmVzcyhub3JtYWxpemVkU3ltYm9sLCBjaGFpbklkKTtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEFzc2V0ICR7YXNzZXR9IGlzIG5vdCBzdXBwb3J0ZWQgb24gY2hhaW4gJHtjaGFpbklkfS4gQXZhaWxhYmxlIGNoYWluczogJHtPYmplY3Qua2V5cyh0b2tlbkluZm8uYWRkcmVzc2VzKS5qb2luKFwiLCBcIil9YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkZHJlc3MsXG4gICAgc3ltYm9sOiB0b2tlbkluZm8uc3ltYm9sLFxuICAgIGRlY2ltYWxzOiB0b2tlbkluZm8uZGVjaW1hbHMsXG4gIH07XG59XG5cbi8qKlxuICogUGFyc2UgaHVtYW4tcmVhZGFibGUgYW1vdW50IHRvIHdlaS9zbWFsbGVzdCB1bml0XG4gKiBAcGFyYW0gYW1vdW50IC0gSHVtYW4tcmVhZGFibGUgYW1vdW50IChlLmcuIDEuNSlcbiAqIEBwYXJhbSBkZWNpbWFscyAtIFRva2VuIGRlY2ltYWxzXG4gKiBAcmV0dXJucyBBbW91bnQgaW4gc21hbGxlc3QgdW5pdCAod2VpIGVxdWl2YWxlbnQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFzc2V0QW1vdW50KGFtb3VudDogbnVtYmVyLCBkZWNpbWFsczogbnVtYmVyKTogYmlnaW50IHtcbiAgLy8gQ29udmVydCBudW1iZXIgdG8gc3RyaW5nIHdpdGggcHJvcGVyIHByZWNpc2lvblxuICBjb25zdCBhbW91bnRTdHIgPSBhbW91bnQudG9TdHJpbmcoKTtcblxuICAvLyBVc2UgdmllbSdzIHBhcnNlVW5pdHMgZm9yIHByb3BlciBkZWNpbWFsIGhhbmRsaW5nXG4gIHJldHVybiBwYXJzZVVuaXRzKGFtb3VudFN0ciwgZGVjaW1hbHMpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgd2VpL3NtYWxsZXN0IHVuaXQgYmFjayB0byBodW1hbi1yZWFkYWJsZSBhbW91bnRcbiAqIEBwYXJhbSBhbW91bnQgLSBBbW91bnQgaW4gc21hbGxlc3QgdW5pdFxuICogQHBhcmFtIGRlY2ltYWxzIC0gVG9rZW4gZGVjaW1hbHNcbiAqIEByZXR1cm5zIEh1bWFuLXJlYWRhYmxlIGFtb3VudCBhcyBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEFzc2V0QW1vdW50KGFtb3VudDogYmlnaW50LCBkZWNpbWFsczogbnVtYmVyKTogbnVtYmVyIHtcbiAgLy8gQ29udmVydCB0byBzdHJpbmcsIHRoZW4gdG8gbnVtYmVyXG4gIGNvbnN0IGRpdmlzb3IgPSAxMG4gKiogQmlnSW50KGRlY2ltYWxzKTtcbiAgY29uc3Qgd2hvbGVQYXJ0ID0gYW1vdW50IC8gZGl2aXNvcjtcbiAgY29uc3QgZnJhY3Rpb25hbFBhcnQgPSBhbW91bnQgJSBkaXZpc29yO1xuXG4gIC8vIEhhbmRsZSBmcmFjdGlvbmFsIHBhcnQgd2l0aCBwcm9wZXIgcHJlY2lzaW9uXG4gIGNvbnN0IGZyYWN0aW9uYWxTdHIgPSBmcmFjdGlvbmFsUGFydC50b1N0cmluZygpLnBhZFN0YXJ0KGRlY2ltYWxzLCBcIjBcIik7XG4gIGNvbnN0IHJlc3VsdCA9IGAke3dob2xlUGFydH0uJHtmcmFjdGlvbmFsU3RyfWA7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQocmVzdWx0KTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBhbmQgcGFyc2UgbGVuZCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gYW1vdW50IC0gSHVtYW4tcmVhZGFibGUgYW1vdW50XG4gKiBAcGFyYW0gYXNzZXQgLSBBc3NldCBpZGVudGlmaWVyXG4gKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIElEXG4gKiBAcmV0dXJucyBQYXJzZWQgbGVuZCBwYXJhbWV0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxlbmRQYXJhbXMoXG4gIGFtb3VudDogbnVtYmVyLFxuICBhc3NldDogQXNzZXRJZGVudGlmaWVyLFxuICBjaGFpbklkOiBTdXBwb3J0ZWRDaGFpbklkXG4pOiB7XG4gIGFtb3VudDogYmlnaW50O1xuICBhc3NldDogUmVzb2x2ZWRBc3NldDtcbn0ge1xuICBpZiAoYW1vdW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkQXNzZXQgPSByZXNvbHZlQXNzZXQoYXNzZXQsIGNoYWluSWQpO1xuICBjb25zdCBwYXJzZWRBbW91bnQgPSBwYXJzZUFzc2V0QW1vdW50KGFtb3VudCwgcmVzb2x2ZWRBc3NldC5kZWNpbWFscyk7XG5cbiAgcmV0dXJuIHtcbiAgICBhbW91bnQ6IHBhcnNlZEFtb3VudCxcbiAgICBhc3NldDogcmVzb2x2ZWRBc3NldCxcbiAgfTtcbn1cbiIsImltcG9ydCB0eXBlIHsgQWRkcmVzcywgSGFzaCwgTG9jYWxBY2NvdW50IH0gZnJvbSBcInZpZW1cIjtcblxuaW1wb3J0IHR5cGUgeyBTdXBwb3J0ZWRDaGFpbklkIH0gZnJvbSBcIkAvY29uc3RhbnRzL2NoYWluc1wiO1xuaW1wb3J0IHR5cGUgeyBUb2tlbkJhbGFuY2UgfSBmcm9tIFwiQC90eXBlcy90b2tlblwiO1xuaW1wb3J0IHR5cGUgeyBBc3NldElkZW50aWZpZXIgfSBmcm9tIFwiQC91dGlscy9hc3NldHNcIjtcbmltcG9ydCB0eXBlIHsgVHJhbnNhY3Rpb25EYXRhIH0gZnJvbSBcIkAvdHlwZXMvdHJhbnNhY3Rpb25cIjtcblxuLyoqXG4gKiBCYXNlIHNtYXJ0IHdhbGxldCBjbGFzc1xuICogQGRlc2NyaXB0aW9uIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIHNtYXJ0IHdhbGxldCBpbXBsZW1lbnRhdGlvbnMgKEVSQy00MzM3IGNvbXBhdGlibGUgd2FsbGV0cykuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTbWFydFdhbGxldCB7XG4gIC8qKiBUaGUgTG9jYWxBY2NvdW50IHVzZWQgZm9yIHNpZ25pbmcgdHJhbnNhY3Rpb25zIG9uIGJlaGFsZiBvZiB0aGlzIHNtYXJ0IHdhbGxldCAqL1xuICBhYnN0cmFjdCBzaWduZXI6IExvY2FsQWNjb3VudDtcblxuICAvKipcbiAgICogR2V0IHRoZSBzbWFydCB3YWxsZXQncyBhZGRyZXNzXG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBkZXBsb3llZCBvciBwcmVkaWN0ZWQgYWRkcmVzcyBvZiB0aGlzIHNtYXJ0IHdhbGxldCBjb250cmFjdC5cbiAgICogRm9yIHVuZGVwbG95ZWQgd2FsbGV0cywgdGhpcyByZXR1cm5zIHRoZSBkZXRlcm1pbmlzdGljIENSRUFURTIgYWRkcmVzcy5cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHdhbGxldCdzIEV0aGVyZXVtIGFkZHJlc3NcbiAgICovXG4gIGFic3RyYWN0IGdldEFkZHJlc3MoKTogUHJvbWlzZTxBZGRyZXNzPjtcblxuICAvKipcbiAgICogR2V0IGFsbCB0b2tlbiBiYWxhbmNlcyBmb3IgdGhpcyB3YWxsZXRcbiAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBiYWxhbmNlcyBmb3IgYWxsIHN1cHBvcnRlZCB0b2tlbnMgaGVsZCBieSB0aGlzIHNtYXJ0IHdhbGxldC5cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgdG9rZW4gYmFsYW5jZXMgd2l0aCBhbW91bnRzIGFuZCBtZXRhZGF0YVxuICAgKi9cbiAgYWJzdHJhY3QgZ2V0QmFsYW5jZSgpOiBQcm9taXNlPFRva2VuQmFsYW5jZVtdPjtcblxuICAvLyBUT0RPOiBhZGQgYWRkU2lnbmVyIG1ldGhvZFxuICAvLyBUT0RPOiBhZGQgcmVtb3ZlU2lnbmVyIG1ldGhvZFxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdXNpbmcgdGhpcyBzbWFydCB3YWxsZXRcbiAgICogQGRlc2NyaXB0aW9uIEV4ZWN1dGVzIGEgdHJhbnNhY3Rpb24gdGhyb3VnaCB0aGUgc21hcnQgd2FsbGV0LCBoYW5kbGluZyBnYXMgc3BvbnNvcnNoaXBcbiAgICogYW5kIEVSQy00MzM3IFVzZXJPcGVyYXRpb24gY3JlYXRpb24gYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uRGF0YSAtIFRoZSB0cmFuc2FjdGlvbiBkYXRhIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIGNoYWluSWQgLSBUYXJnZXQgYmxvY2tjaGFpbiBjaGFpbiBJRFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgdHJhbnNhY3Rpb24gaGFzaFxuICAgKi9cbiAgYWJzdHJhY3Qgc2VuZChcbiAgICB0cmFuc2FjdGlvbkRhdGE6IFRyYW5zYWN0aW9uRGF0YSwgLy8gVE9ETzogQWRkIGEgY29ycmVjdCB0eXBlXG4gICAgY2hhaW5JZDogU3VwcG9ydGVkQ2hhaW5JZFxuICApOiBQcm9taXNlPEhhc2g+O1xuXG4gIC8qKlxuICAgKiBTZW5kIHRva2VucyB0byBhbm90aGVyIGFkZHJlc3NcbiAgICogQGRlc2NyaXB0aW9uIFByZXBhcmVzIHRyYW5zYWN0aW9uIGRhdGEgZm9yIHNlbmRpbmcgdG9rZW5zIGZyb20gdGhpcyBzbWFydCB3YWxsZXRcbiAgICogdG8gYSByZWNpcGllbnQgYWRkcmVzcy4gUmV0dXJucyB0cmFuc2FjdGlvbiBkYXRhIHRoYXQgY2FuIGJlIGV4ZWN1dGVkIHZpYSBzZW5kKCkuXG4gICAqIEBwYXJhbSBhbW91bnQgLSBBbW91bnQgdG8gc2VuZCBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXRcbiAgICogQHBhcmFtIGFzc2V0IC0gQXNzZXQgaWRlbnRpZmllciBmb3IgdGhlIHRva2VuIHRvIHNlbmRcbiAgICogQHBhcmFtIHJlY2lwaWVudEFkZHJlc3MgLSBEZXN0aW5hdGlvbiBhZGRyZXNzIGZvciB0aGUgdG9rZW5zXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHByZXBhcmVkIHRyYW5zYWN0aW9uIGRhdGFcbiAgICovXG4gIGFic3RyYWN0IHNlbmRUb2tlbnMoXG4gICAgYW1vdW50OiBudW1iZXIsXG4gICAgYXNzZXQ6IEFzc2V0SWRlbnRpZmllcixcbiAgICByZWNpcGllbnRBZGRyZXNzOiBBZGRyZXNzXG4gICk6IFByb21pc2U8VHJhbnNhY3Rpb25EYXRhPjsgLy8gVE9ETzogQWRkIGEgY29ycmVjdCB0eXBlXG5cbiAgLy8gICAvKipcbiAgLy8gICAgKiBXaXRoZHJhdyB0b2tlbnMgZnJvbSB0aGlzIHNtYXJ0IHdhbGxldCB0byBhIGZpYXRcbiAgLy8gICAgKiBAZGVzY3JpcHRpb24gUHJlcGFyZXMgYW4gb2ZmIHJhbXAgbGluayB0byB3aXRoZHJhdyB0b2tlbnMgZnJvbSB0aGlzIHNtYXJ0IHdhbGxldFxuICAvLyAgICAqIHRvIGEgZmlhdCBhY2NvdW50IChiYW5rIGFjY291bnQpXG4gIC8vICAgICogQHBhcmFtIGFtb3VudCAtIEFtb3VudCB0byB3aXRoZHJhdyBpbiBodW1hbi1yZWFkYWJsZSBmb3JtYXRcbiAgLy8gICAgKiBAcGFyYW0gYXNzZXQgLSBBc3NldCBpZGVudGlmaWVyIGZvciB0aGUgdG9rZW4gdG8gd2l0aGRyYXdcbiAgLy8gICAgKiBAcGFyYW0gYmFua0FjY291bnQgLSBEZXN0aW5hdGlvbiBiYW5rIGFjY291bnQgZm9yIHRoZSB0b2tlbnNcbiAgLy8gICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBwcmVwYXJlZCB0cmFuc2FjdGlvbiBkYXRhXG4gIC8vICAgICovXG4gIC8vICAgYWJzdHJhY3Qgd2l0aGRyYXdUb2tlbnMoXG4gIC8vICAgICBhbW91bnQ6IG51bWJlcixcbiAgLy8gICAgIGFzc2V0OiBBc3NldElkZW50aWZpZXIsXG4gIC8vICAgICBiYW5rQWNjb3VudDogc3RyaW5nXG4gIC8vICAgKTogUHJvbWlzZTxzdHJpbmc+OyAvLyBUT0RPOiBBZGQgYSBjb3JyZWN0IHR5cGVcbn1cbiIsImltcG9ydCB0eXBlIHsgQWRkcmVzcyB9IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgdHlwZSB7IFdlYkF1dGhuQWNjb3VudCB9IGZyb20gXCJ2aWVtL2FjY291bnQtYWJzdHJhY3Rpb25cIjtcblxuaW1wb3J0IHR5cGUge1xuICBDcmVhdGVTbWFydFdhbGxldE9wdGlvbnMsXG4gIENyZWF0ZVdhbGxldFdpdGhFbWJlZGRlZFNpZ25lck9wdGlvbnMsXG4gIEdldEVtYmVkZGVkV2FsbGV0T3B0aW9ucyxcbiAgR2V0U21hcnRXYWxsZXRPcHRpb25zLFxuICBHZXRTbWFydFdhbGxldFdpdGhFbWJlZGRlZFNpZ25lck9wdGlvbnMsXG59IGZyb20gXCJAL3R5cGVzL3dhbGxldFwiO1xuaW1wb3J0IHR5cGUgeyBFbWJlZGRlZFdhbGxldCB9IGZyb20gXCJAL3dhbGxldC9iYXNlL3dhbGxldHMvRW1iZWRkZWRXYWxsZXRcIjtcbmltcG9ydCB0eXBlIHsgU21hcnRXYWxsZXQgfSBmcm9tIFwiQC93YWxsZXQvYmFzZS93YWxsZXRzL1NtYXJ0V2FsbGV0XCI7XG5pbXBvcnQgdHlwZSB7IEVtYmVkZGVkV2FsbGV0UHJvdmlkZXIgfSBmcm9tIFwiQC93YWxsZXQvYmFzZS9wcm92aWRlcnMvRW1iZWRkZWRXYWxsZXRQcm92aWRlclwiO1xuaW1wb3J0IHR5cGUgeyBTbWFydFdhbGxldFByb3ZpZGVyIH0gZnJvbSBcIkAvd2FsbGV0L2Jhc2UvcHJvdmlkZXJzL1NtYXJ0V2FsbGV0UHJvdmlkZXJcIjtcblxuLy8gV0hBVCBJUyBUSElTIENMQVNTP1xuLy8gVGhpcyBpcyBhIHByb3ZpZGVyIGNsYXNzIHRoYXQgaXMgdXNlZCB0byBtYW5hZ2Ugc21hcnQgYW5kIGVtYmVkZGVkIHdhbGxldHNcbi8vIEN1cnJlbnRseSBzdXBwb3J0ZWQgUHJpdnkgZW1iZWRkZWQgd2FsbGV0IHByb3ZpZGVyIGFuZCBEZWZhdWx0IHNtYXJ0IHdhbGxldCBwcm92aWRlclxuLy8gTmV3IGZ1cnRoZXIgd2FsbGV0IHByb3ZpZGVycyAoZS5nLiBEeW5hbWljIG9yIExpdCkgY2FuIGJlIGFkZGVkIGhlcmVcblxuLyoqXG4gKiBVbmlmaWVkIFdhbGxldCBQcm92aWRlclxuICogQGRlc2NyaXB0aW9uIE1haW4gd2FsbGV0IHByb3ZpZGVyIHRoYXQgY29tYmluZXMgZW1iZWRkZWQgd2FsbGV0IGFuZCBzbWFydCB3YWxsZXQgZnVuY3Rpb25hbGl0eS5cbiAqIFByb3ZpZGVzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGFsbCB3YWxsZXQgb3BlcmF0aW9ucyB3aGlsZSBzdXBwb3J0aW5nIHBsdWdnYWJsZSBwcm92aWRlcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXYWxsZXRQcm92aWRlciB7XG4gIHB1YmxpYyByZWFkb25seSBlbWJlZGRlZFdhbGxldFByb3ZpZGVyOiBFbWJlZGRlZFdhbGxldFByb3ZpZGVyO1xuICBwdWJsaWMgcmVhZG9ubHkgc21hcnRXYWxsZXRQcm92aWRlcjogU21hcnRXYWxsZXRQcm92aWRlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBlbWJlZGRlZFdhbGxldFByb3ZpZGVyOiBFbWJlZGRlZFdhbGxldFByb3ZpZGVyLFxuICAgIHNtYXJ0V2FsbGV0UHJvdmlkZXI6IFNtYXJ0V2FsbGV0UHJvdmlkZXJcbiAgKSB7XG4gICAgdGhpcy5lbWJlZGRlZFdhbGxldFByb3ZpZGVyID0gZW1iZWRkZWRXYWxsZXRQcm92aWRlcjtcbiAgICB0aGlzLnNtYXJ0V2FsbGV0UHJvdmlkZXIgPSBzbWFydFdhbGxldFByb3ZpZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBlbWJlZGRlZCB3YWxsZXRcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgb25seSBhbiBlbWJlZGRlZCB3YWxsZXQgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgZW1iZWRkZWQgd2FsbGV0IHByb3ZpZGVyLlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCBlbWJlZGRlZCB3YWxsZXQgaW5zdGFuY2VcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUVtYmVkZGVkV2FsbGV0KCk6IFByb21pc2U8RW1iZWRkZWRXYWxsZXQ+IHtcbiAgICByZXR1cm4gdGhpcy5lbWJlZGRlZFdhbGxldFByb3ZpZGVyLmNyZWF0ZVdhbGxldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzbWFydCB3YWxsZXRcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgb25seSBhIHNtYXJ0IHdhbGxldCB1c2luZyB0aGUgY29uZmlndXJlZCBzbWFydCB3YWxsZXQgcHJvdmlkZXIuXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IGFscmVhZHkgaGF2ZSBhIHNpZ25lciBhbmQgd2FudCB0byBjcmVhdGUgYSBzbWFydCB3YWxsZXQgd2l0aG91dFxuICAgKiBjcmVhdGluZyBhbiBlbWJlZGRlZCB3YWxsZXQuIFlvdSBtdXN0IHByb3ZpZGUgeW91ciBvd24gc2lnbmVyIGFuZCBvd25lcnMgYXJyYXkuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBTbWFydCB3YWxsZXQgY3JlYXRpb24gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gcGFyYW1zLm93bmVycyAtIEFycmF5IG9mIG93bmVycyBmb3IgdGhlIHNtYXJ0IHdhbGxldCAoYWRkcmVzc2VzIG9yIFdlYkF1dGhuIHB1YmxpYyBrZXlzKVxuICAgKiBAcGFyYW0gcGFyYW1zLnNpZ25lciAtIExvY2FsIGFjY291bnQgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtcy5ub25jZSAtIE9wdGlvbmFsIG5vbmNlIGZvciBzbWFydCB3YWxsZXQgYWRkcmVzcyBnZW5lcmF0aW9uIChkZWZhdWx0cyB0byAwKVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCBzbWFydCB3YWxsZXQgaW5zdGFuY2VcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNtYXJ0V2FsbGV0KFxuICAgIHBhcmFtczogQ3JlYXRlU21hcnRXYWxsZXRPcHRpb25zXG4gICk6IFByb21pc2U8U21hcnRXYWxsZXQ+IHtcbiAgICBjb25zdCB7IG93bmVycywgc2lnbmVyLCBub25jZSB9ID0gcGFyYW1zO1xuXG4gICAgcmV0dXJuIHRoaXMuc21hcnRXYWxsZXRQcm92aWRlci5jcmVhdGVXYWxsZXQoe1xuICAgICAgb3duZXJzLFxuICAgICAgc2lnbmVyLFxuICAgICAgbm9uY2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHNtYXJ0IHdhbGxldCB3aXRoIGVtYmVkZGVkIHdhbGxldCBhcyBzaWduZXJcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYm90aCBhbiBlbWJlZGRlZCB3YWxsZXQgYW5kIGEgc21hcnQgd2FsbGV0LCB3aXRoIHRoZSBlbWJlZGRlZCB3YWxsZXRcbiAgICogYXV0b21hdGljYWxseSBhZGRlZCBhcyBvbmUgb2YgdGhlIG93bmVycy9zaWduZXJzIG9mIHRoZSBzbWFydCB3YWxsZXQuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBPcHRpb25hbCB3YWxsZXQgY3JlYXRpb24gcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gcGFyYW1zLm93bmVycyAtIE9wdGlvbmFsIGFycmF5IG9mIGFkZGl0aW9uYWwgb3duZXJzIGZvciB0aGUgc21hcnQgd2FsbGV0LiBUaGUgZW1iZWRkZWQgd2FsbGV0IHdpbGwgYmUgYWRkZWQgdG8gdGhpcyBhcnJheSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgKiBAcGFyYW0gcGFyYW1zLmVtYmVkZGVkV2FsbGV0SW5kZXggLSBPcHRpb25hbCBpbmRleCB3aGVyZSB0aGUgZW1iZWRkZWQgd2FsbGV0IHNob3VsZCBiZSBpbnNlcnRlZCBpbiB0aGUgb3duZXJzIGFycmF5LiBJZiBub3Qgc3BlY2lmaWVkLCBlbWJlZGRlZCB3YWxsZXQgaXMgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAqIEBwYXJhbSBwYXJhbXMubm9uY2UgLSBPcHRpb25hbCBub25jZSBmb3Igc21hcnQgd2FsbGV0IGFkZHJlc3MgZ2VuZXJhdGlvbiAoZGVmYXVsdHMgdG8gMClcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNyZWF0ZWQgc21hcnQgd2FsbGV0IGluc3RhbmNlXG4gICAqL1xuICBhc3luYyBjcmVhdGVXYWxsZXRXaXRoRW1iZWRkZWRTaWduZXIoXG4gICAgcGFyYW1zPzogQ3JlYXRlV2FsbGV0V2l0aEVtYmVkZGVkU2lnbmVyT3B0aW9uc1xuICApOiBQcm9taXNlPFNtYXJ0V2FsbGV0PiB7XG4gICAgY29uc3QgeyBvd25lcnM6IG93bmVyc1BhcmFtLCBlbWJlZGRlZFdhbGxldEluZGV4LCBub25jZSB9ID0gcGFyYW1zIHx8IHt9O1xuICAgIGNvbnN0IGVtYmVkZGVkV2FsbGV0ID0gYXdhaXQgdGhpcy5lbWJlZGRlZFdhbGxldFByb3ZpZGVyLmNyZWF0ZVdhbGxldCgpO1xuICAgIGNvbnN0IGFjY291bnQgPSBhd2FpdCBlbWJlZGRlZFdhbGxldC5hY2NvdW50KCk7XG5cbiAgICBsZXQgb3duZXJzOiBBcnJheTxBZGRyZXNzIHwgV2ViQXV0aG5BY2NvdW50PjtcbiAgICBpZiAob3duZXJzUGFyYW0pIHtcbiAgICAgIG93bmVycyA9IFsuLi5vd25lcnNQYXJhbV07IC8vIENyZWF0ZSBhIGNvcHkgdG8gYXZvaWQgbXV0YXRpbmcgdGhlIG9yaWdpbmFsXG4gICAgICBjb25zdCBpbnNlcnRJbmRleCA9IGVtYmVkZGVkV2FsbGV0SW5kZXggPz8gb3duZXJzLmxlbmd0aDsgLy8gRGVmYXVsdCB0byBlbmQgaWYgbm90IHNwZWNpZmllZFxuICAgICAgb3duZXJzLnNwbGljZShpbnNlcnRJbmRleCwgMCwgZW1iZWRkZWRXYWxsZXQuYWRkcmVzcyk7IC8vIEluc2VydCBlbWJlZGRlZCB3YWxsZXQgYXQgc3BlY2lmaWVkIGluZGV4XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bmVycyA9IFtlbWJlZGRlZFdhbGxldC5hZGRyZXNzXTsgLy8gRGVmYXVsdCB0byBqdXN0IHRoZSBlbWJlZGRlZCB3YWxsZXRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zbWFydFdhbGxldFByb3ZpZGVyLmNyZWF0ZVdhbGxldCh7XG4gICAgICBvd25lcnMsXG4gICAgICBzaWduZXI6IGFjY291bnQsXG4gICAgICBub25jZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gZXhpc3Rpbmcgc21hcnQgd2FsbGV0IHVzaW5nIGVtYmVkZGVkIHdhbGxldCBhcyBzaWduZXJcbiAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBhbiBlbWJlZGRlZCB3YWxsZXQgYnkgd2FsbGV0SWQgYW5kIHVzZXMgaXQgYXMgdGhlIHNpZ25lciB0byBnZXRcbiAgICogdGhlIGNvcnJlc3BvbmRpbmcgc21hcnQgd2FsbGV0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSBoYXZlXG4gICAqIGFuIGVtYmVkZGVkIHdhbGxldCBJRCBhbmQgd2FudCB0byBhY2Nlc3MgdGhlIGFzc29jaWF0ZWQgc21hcnQgd2FsbGV0IGZ1bmN0aW9uYWxpdHkuXG4gICAqIEBkZXYgSWYgbmVpdGhlciB3YWxsZXRBZGRyZXNzIG5vciBkZXBsb3ltZW50T3duZXJzIGlzIHByb3ZpZGVkLFxuICAgKiBkZWZhdWx0cyB0byB1c2luZyB0aGUgZW1iZWRkZWQgd2FsbGV0IGFzIHRoZSBzaW5nbGUgb3duZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBXYWxsZXQgcmV0cmlldmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRJZCAtIElEIG9mIHRoZSBlbWJlZGRlZCB3YWxsZXQgdG8gdXNlIGFzIHNpZ25lclxuICAgKiBAcGFyYW0gcGFyYW1zLmRlcGxveW1lbnRPd25lcnMgLSBPcHRpb25hbCBhcnJheSBvZiBvcmlnaW5hbCBkZXBsb3ltZW50IG93bmVycyBmb3Igc21hcnQgd2FsbGV0IGFkZHJlc3MgY2FsY3VsYXRpb24uIElmIG5vdCBwcm92aWRlZCBhbmQgd2FsbGV0QWRkcmVzcyBpcyBhbHNvIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gdXNpbmcgdGhlIGVtYmVkZGVkIHdhbGxldCBhcyBzaW5nbGUgb3duZXIuXG4gICAqIEBwYXJhbSBwYXJhbXMuc2lnbmVyT3duZXJJbmRleCAtIEN1cnJlbnQgaW5kZXggb2YgdGhlIHNpZ25lciBpbiB0aGUgc21hcnQgd2FsbGV0J3MgY3VycmVudCBvd25lcnMgYXJyYXkgKHVzZWQgZm9yIHRyYW5zYWN0aW9uIHNpZ25pbmcpLiBEZWZhdWx0cyB0byAwIGlmIG5vdCBzcGVjaWZpZWQuIFRoaXMgbWF5IGRpZmZlciBmcm9tIHRoZSBvcmlnaW5hbCBkZXBsb3ltZW50IGluZGV4IGlmIG93bmVycyBoYXZlIGJlZW4gbW9kaWZpZWQuXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0QWRkcmVzcyAtIE9wdGlvbmFsIGV4cGxpY2l0IHNtYXJ0IHdhbGxldCBhZGRyZXNzIChza2lwcyBhZGRyZXNzIGNhbGN1bGF0aW9uKVxuICAgKiBAcGFyYW0gcGFyYW1zLm5vbmNlIC0gT3B0aW9uYWwgbm9uY2UgdXNlZCBkdXJpbmcgc21hcnQgd2FsbGV0IGNyZWF0aW9uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzbWFydCB3YWxsZXQgaW5zdGFuY2Ugd2l0aCBlbWJlZGRlZCB3YWxsZXQgYXMgc2lnbmVyXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgZW1iZWRkZWQgd2FsbGV0IGlzIG5vdCBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0U21hcnRXYWxsZXRXaXRoRW1iZWRkZWRTaWduZXIoXG4gICAgcGFyYW1zOiBHZXRTbWFydFdhbGxldFdpdGhFbWJlZGRlZFNpZ25lck9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgeyB3YWxsZXRJZCwgZGVwbG95bWVudE93bmVycywgd2FsbGV0QWRkcmVzcyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGVtYmVkZGVkV2FsbGV0ID0gYXdhaXQgdGhpcy5lbWJlZGRlZFdhbGxldFByb3ZpZGVyLmdldFdhbGxldCh7XG4gICAgICB3YWxsZXRJZCxcbiAgICB9KTtcbiAgICBpZiAoIWVtYmVkZGVkV2FsbGV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbWJlZGRlZCB3YWxsZXQgbm90IGZvdW5kXCIpO1xuICAgIH1cbiAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgZW1iZWRkZWRXYWxsZXQuYWNjb3VudCgpO1xuXG4gICAgLy8gSWYgbmVpdGhlciB3YWxsZXRBZGRyZXNzIG5vciBkZXBsb3ltZW50T3duZXJzIHByb3ZpZGVkLCBkZWZhdWx0IHRvIGVtYmVkZGVkIHdhbGxldCBhcyBzaW5nbGUgb3duZXJcbiAgICBjb25zdCBmaW5hbERlcGxveW1lbnRPd25lcnMgPVxuICAgICAgZGVwbG95bWVudE93bmVycyB8fFxuICAgICAgKHdhbGxldEFkZHJlc3MgPyB1bmRlZmluZWQgOiBbZW1iZWRkZWRXYWxsZXQuYWRkcmVzc10pO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0U21hcnRXYWxsZXQoe1xuICAgICAgc2lnbmVyOiBhY2NvdW50LFxuICAgICAgLi4ucGFyYW1zLFxuICAgICAgZGVwbG95bWVudE93bmVyczogZmluYWxEZXBsb3ltZW50T3duZXJzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBleGlzdGluZyBlbWJlZGRlZCB3YWxsZXRcbiAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBhbiBlbWJlZGRlZCB3YWxsZXQgYnkgd2FsbGV0SWQuIFRoaXMgaXMgdXNlZnVsIHdoZW4geW91IGhhdmUgYW4gZW1iZWRkZWQgd2FsbGV0IElEIGFuZFxuICAgKiB3YW50IHRvIGFjY2VzcyB0aGUgYXNzb2NpYXRlZCBlbWJlZGRlZCB3YWxsZXQgZnVuY3Rpb25hbGl0eS5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFdhbGxldCByZXRyaWV2YWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldElkIC0gSUQgb2YgdGhlIGVtYmVkZGVkIHdhbGxldCB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZW1iZWRkZWQgd2FsbGV0IGluc3RhbmNlXG4gICAqL1xuICBhc3luYyBnZXRFbWJlZGRlZFdhbGxldChwYXJhbXM6IEdldEVtYmVkZGVkV2FsbGV0T3B0aW9ucykge1xuICAgIGNvbnN0IHsgd2FsbGV0SWQgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gdGhpcy5lbWJlZGRlZFdhbGxldFByb3ZpZGVyLmdldFdhbGxldCh7XG4gICAgICB3YWxsZXRJZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gZXhpc3Rpbmcgc21hcnQgd2FsbGV0IHdpdGggYSBwcm92aWRlZCBzaWduZXJcbiAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBhIHNtYXJ0IHdhbGxldCB1c2luZyBhIGRpcmVjdGx5IHByb3ZpZGVkIHNpZ25lci4gVGhpcyBpcyB1c2VmdWwgd2hlblxuICAgKiB5b3UgYWxyZWFkeSBoYXZlIGEgTG9jYWxBY2NvdW50IHNpZ25lciBhbmQgd2FudCB0byBhY2Nlc3MgYW4gZXhpc3Rpbmcgc21hcnQgd2FsbGV0IHdpdGhvdXRcbiAgICogZ29pbmcgdGhyb3VnaCB0aGUgZW1iZWRkZWQgd2FsbGV0IHByb3ZpZGVyLiBVc2UgdGhpcyBpbnN0ZWFkIG9mIGdldFNtYXJ0V2FsbGV0V2l0aEVtYmVkZGVkU2lnbmVyXG4gICAqIHdoZW4geW91IGhhdmUgZGlyZWN0IGNvbnRyb2wgb3ZlciB0aGUgc2lnbmVyLlxuICAgKiBAcGFyYW0gc2lnbmVyIC0gTG9jYWwgYWNjb3VudCB0byB1c2UgZm9yIHNpZ25pbmcgdHJhbnNhY3Rpb25zIG9uIHRoZSBzbWFydCB3YWxsZXRcbiAgICogQHBhcmFtIGdldFdhbGxldFBhcmFtcyAtIFdhbGxldCByZXRyaWV2YWwgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0gZ2V0V2FsbGV0UGFyYW1zLmRlcGxveW1lbnRPd25lcnMgLSBBcnJheSBvZiBvcmlnaW5hbCBkZXBsb3ltZW50IG93bmVycyBmb3Igc21hcnQgd2FsbGV0IGFkZHJlc3MgY2FsY3VsYXRpb24uIFJlcXVpcmVkIGlmIHdhbGxldEFkZHJlc3Mgbm90IHByb3ZpZGVkLiBNdXN0IG1hdGNoIHRoZSBleGFjdCBvd25lcnMgYXJyYXkgdXNlZCBkdXJpbmcgd2FsbGV0IGRlcGxveW1lbnQuXG4gICAqIEBwYXJhbSBnZXRXYWxsZXRQYXJhbXMuc2lnbmVyT3duZXJJbmRleCAtIEN1cnJlbnQgaW5kZXggb2YgdGhlIHNpZ25lciBpbiB0aGUgc21hcnQgd2FsbGV0J3MgY3VycmVudCBvd25lcnMgYXJyYXkgKHVzZWQgZm9yIHRyYW5zYWN0aW9uIHNpZ25pbmcpLiBEZWZhdWx0cyB0byAwIGlmIG5vdCBzcGVjaWZpZWQuIFRoaXMgbWF5IGRpZmZlciBmcm9tIHRoZSBvcmlnaW5hbCBkZXBsb3ltZW50IGluZGV4IGlmIG93bmVycyBoYXZlIGJlZW4gbW9kaWZpZWQuXG4gICAqIEBwYXJhbSBnZXRXYWxsZXRQYXJhbXMud2FsbGV0QWRkcmVzcyAtIE9wdGlvbmFsIGV4cGxpY2l0IHNtYXJ0IHdhbGxldCBhZGRyZXNzIChza2lwcyBhZGRyZXNzIGNhbGN1bGF0aW9uKVxuICAgKiBAcGFyYW0gZ2V0V2FsbGV0UGFyYW1zLm5vbmNlIC0gT3B0aW9uYWwgbm9uY2UgdXNlZCBkdXJpbmcgc21hcnQgd2FsbGV0IGNyZWF0aW9uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzbWFydCB3YWxsZXQgaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgc2lnbmVyXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgbmVpdGhlciB3YWxsZXRBZGRyZXNzIG5vciBkZXBsb3ltZW50T3duZXJzIHByb3ZpZGVkXG4gICAqL1xuICBhc3luYyBnZXRTbWFydFdhbGxldChwYXJhbXM6IEdldFNtYXJ0V2FsbGV0T3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25lcixcbiAgICAgIGRlcGxveW1lbnRPd25lcnMsXG4gICAgICBzaWduZXJPd25lckluZGV4LFxuICAgICAgd2FsbGV0QWRkcmVzczogd2FsbGV0QWRkcmVzc1BhcmFtLFxuICAgICAgbm9uY2UsXG4gICAgfSA9IHBhcmFtcztcblxuICAgIGlmICghd2FsbGV0QWRkcmVzc1BhcmFtICYmICFkZXBsb3ltZW50T3duZXJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJFaXRoZXIgd2FsbGV0QWRkcmVzcyBvciBkZXBsb3ltZW50T3duZXJzIGFycmF5IG11c3QgYmUgcHJvdmlkZWQgdG8gbG9jYXRlIHRoZSBzbWFydCB3YWxsZXRcIlxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkVpdGhlciB3YWxsZXRBZGRyZXNzIG9yIGRlcGxveW1lbnRPd25lcnMgYXJyYXkgbXVzdCBiZSBwcm92aWRlZCB0byBsb2NhdGUgdGhlIHNtYXJ0IHdhbGxldFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3duZXJJbmRleCA9IHNpZ25lck93bmVySW5kZXggPz8gMDtcblxuICAgIGNvbnN0IHdhbGxldEFkZHJlc3MgPVxuICAgICAgd2FsbGV0QWRkcmVzc1BhcmFtIHx8XG4gICAgICAoYXdhaXQgdGhpcy5zbWFydFdhbGxldFByb3ZpZGVyLmdldFdhbGxldEFkZHJlc3Moe1xuICAgICAgICAvLyBTYWZlIHRvIHVzZSAhIHNpbmNlIHdlIHZhbGlkYXRlZCBhYm92ZVxuICAgICAgICBvd25lcnM6IGRlcGxveW1lbnRPd25lcnMhLFxuICAgICAgICBub25jZSxcbiAgICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcy5zbWFydFdhbGxldFByb3ZpZGVyLmdldFdhbGxldCh7XG4gICAgICB3YWxsZXRBZGRyZXNzLFxuICAgICAgc2lnbmVyLFxuICAgICAgb3duZXJJbmRleCxcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBQcml2eUNsaWVudCB9IGZyb20gXCJAcHJpdnktaW8vc2VydmVyLWF1dGhcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwidmllbVwiO1xuXG5pbXBvcnQgdHlwZSB7IENoYWluTWFuYWdlciB9IGZyb20gXCJAL3Rvb2xzL0NoYWluTWFuYWdlclwiO1xuLy8gaW1wb3J0IHR5cGUgeyBMZW5kUHJvdmlkZXIgfSBmcm9tIFwiQC90eXBlcy9sZW5kLmpzXCI7XG5pbXBvcnQgeyBQcml2eVdhbGxldCB9IGZyb20gXCJAL3dhbGxldC9Qcml2eVdhbGxldFwiO1xuaW1wb3J0IHsgRW1iZWRkZWRXYWxsZXRQcm92aWRlciB9IGZyb20gXCJAL3dhbGxldC9iYXNlL3Byb3ZpZGVycy9FbWJlZGRlZFdhbGxldFByb3ZpZGVyXCI7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0dGluZyBhbGwgd2FsbGV0c1xuICogQGRlc2NyaXB0aW9uIFBhcmFtZXRlcnMgZm9yIGZpbHRlcmluZyBhbmQgcGFnaW5hdGluZyB3YWxsZXQgcmVzdWx0c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFByaXZ5UHJvdmlkZXJHZXRBbGxXYWxsZXRzT3B0aW9ucyB7XG4gIC8qKiBNYXhpbXVtIG51bWJlciBvZiB3YWxsZXRzIHRvIHJldHVybiAqL1xuICBsaW1pdD86IG51bWJlcjtcbiAgLyoqIEN1cnNvciBmb3IgcGFnaW5hdGlvbiAqL1xuICBjdXJzb3I/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUHJpdnkgd2FsbGV0IHByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gKiBAZGVzY3JpcHRpb24gV2FsbGV0IHByb3ZpZGVyIGltcGxlbWVudGF0aW9uIHVzaW5nIFByaXZ5IHNlcnZpY2VcbiAqL1xuZXhwb3J0IGNsYXNzIFByaXZ5RW1iZWRkZWRXYWxsZXRQcm92aWRlciBleHRlbmRzIEVtYmVkZGVkV2FsbGV0UHJvdmlkZXIge1xuICBwdWJsaWMgcHJpdnk6IFByaXZ5Q2xpZW50O1xuICBwcml2YXRlIGNoYWluTWFuYWdlcjogQ2hhaW5NYW5hZ2VyO1xuICAvLyAgIHByaXZhdGUgbGVuZFByb3ZpZGVyOiBMZW5kUHJvdmlkZXI7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUHJpdnkgd2FsbGV0IHByb3ZpZGVyXG4gICAqIEBwYXJhbSBwcml2eUNsaWVudCAtIFByaXZ5IGNsaWVudCBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdnlDbGllbnQ6IFByaXZ5Q2xpZW50LFxuICAgIGNoYWluTWFuYWdlcjogQ2hhaW5NYW5hZ2VyXG4gICAgLy8gbGVuZFByb3ZpZGVyOiBMZW5kUHJvdmlkZXJcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnByaXZ5ID0gcHJpdnlDbGllbnQ7XG4gICAgdGhpcy5jaGFpbk1hbmFnZXIgPSBjaGFpbk1hbmFnZXI7XG4gICAgLy8gdGhpcy5sZW5kUHJvdmlkZXIgPSBsZW5kUHJvdmlkZXI7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIG5ldyB3YWxsZXQgdmlhIFByaXZ5XG4gICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgbmV3IHdhbGxldCB1c2luZyBQcml2eSdzIHdhbGxldCBBUElcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gbmV3IHdhbGxldCBpbnN0YW5jZVxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHdhbGxldCBjcmVhdGlvbiBmYWlsc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlV2FsbGV0KCk6IFByb21pc2U8UHJpdnlXYWxsZXQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgdGhpcy5wcml2eS53YWxsZXRBcGkuY3JlYXRlV2FsbGV0KHtcbiAgICAgICAgY2hhaW5UeXBlOiBcImV0aGVyZXVtXCIsXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgd2FsbGV0SW5zdGFuY2UgPSBuZXcgUHJpdnlXYWxsZXQoXG4gICAgICAgIHRoaXMucHJpdnksXG4gICAgICAgIHdhbGxldC5pZCxcbiAgICAgICAgZ2V0QWRkcmVzcyh3YWxsZXQuYWRkcmVzcyksXG4gICAgICAgIHRoaXMuY2hhaW5NYW5hZ2VyXG4gICAgICAgIC8vIHRoaXMubGVuZFByb3ZpZGVyXG4gICAgICApO1xuICAgICAgcmV0dXJuIHdhbGxldEluc3RhbmNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSB3YWxsZXQ6IFwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgd2FsbGV0OiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2FsbGV0IGJ5IHdhbGxldCBJRCB2aWEgUHJpdnlcbiAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyB3YWxsZXQgaW5mb3JtYXRpb24gZnJvbSBQcml2eSBzZXJ2aWNlXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGNvbnRhaW5pbmcgd2FsbGV0SWRcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gd2FsbGV0XG4gICAqL1xuICBhc3luYyBnZXRXYWxsZXQocGFyYW1zOiB7IHdhbGxldElkOiBzdHJpbmcgfSk6IFByb21pc2U8UHJpdnlXYWxsZXQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgdGhpcy5wcml2eS53YWxsZXRBcGkuZ2V0V2FsbGV0KHtcbiAgICAgICAgaWQ6IHBhcmFtcy53YWxsZXRJZCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB3YWxsZXRJbnN0YW5jZSA9IG5ldyBQcml2eVdhbGxldChcbiAgICAgICAgdGhpcy5wcml2eSxcbiAgICAgICAgd2FsbGV0LmlkLFxuICAgICAgICBnZXRBZGRyZXNzKHdhbGxldC5hZGRyZXNzKSxcbiAgICAgICAgdGhpcy5jaGFpbk1hbmFnZXJcbiAgICAgICAgLy8gdGhpcy5sZW5kUHJvdmlkZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gd2FsbGV0SW5zdGFuY2U7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZXQgd2FsbGV0IHdpdGggaWQ6ICR7cGFyYW1zLndhbGxldElkfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHdhbGxldHMgdmlhIFByaXZ5XG4gICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgYWxsIHdhbGxldHMgZnJvbSBQcml2eSBzZXJ2aWNlIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIHdhbGxldHNcbiAgICovXG4gIGFzeW5jIGdldEFsbFdhbGxldHMoXG4gICAgb3B0aW9ucz86IFByaXZ5UHJvdmlkZXJHZXRBbGxXYWxsZXRzT3B0aW9uc1xuICApOiBQcm9taXNlPFByaXZ5V2FsbGV0W10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZ5LndhbGxldEFwaS5nZXRXYWxsZXRzKHtcbiAgICAgICAgbGltaXQ6IG9wdGlvbnM/LmxpbWl0LFxuICAgICAgICBjdXJzb3I6IG9wdGlvbnM/LmN1cnNvcixcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5tYXAoKHdhbGxldCkgPT4ge1xuICAgICAgICBjb25zdCB3YWxsZXRJbnN0YW5jZSA9IG5ldyBQcml2eVdhbGxldChcbiAgICAgICAgICB0aGlzLnByaXZ5LFxuICAgICAgICAgIHdhbGxldC5pZCxcbiAgICAgICAgICBnZXRBZGRyZXNzKHdhbGxldC5hZGRyZXNzKSxcbiAgICAgICAgICB0aGlzLmNoYWluTWFuYWdlclxuICAgICAgICAgIC8vICAgdGhpcy5sZW5kUHJvdmlkZXJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldEluc3RhbmNlO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcmV0cmlldmUgd2FsbGV0c1wiKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgUHJpdnlDbGllbnQgfSBmcm9tIFwiQHByaXZ5LWlvL3NlcnZlci1hdXRoXCI7XG5pbXBvcnQge1xuICBjcmVhdGVWaWVtQWNjb3VudCxcbiAgdHlwZSBHZXRWaWVtQWNjb3VudElucHV0VHlwZSxcbn0gZnJvbSBcIkBwcml2eS1pby9zZXJ2ZXItYXV0aC92aWVtXCI7XG5pbXBvcnQge1xuICB0eXBlIEFkZHJlc3MsXG4gIGNyZWF0ZVdhbGxldENsaWVudCxcbiAgdHlwZSBIYXNoLFxuICBodHRwLFxuICB0eXBlIExvY2FsQWNjb3VudCxcbiAgdHlwZSBXYWxsZXRDbGllbnQsXG59IGZyb20gXCJ2aWVtXCI7XG5pbXBvcnQgeyB1bmljaGFpbiB9IGZyb20gXCJ2aWVtL2NoYWluc1wiO1xuXG5pbXBvcnQgdHlwZSB7IFN1cHBvcnRlZENoYWluSWQgfSBmcm9tIFwiQC9jb25zdGFudHMvY2hhaW5zXCI7XG5pbXBvcnQgdHlwZSB7IENoYWluTWFuYWdlciB9IGZyb20gXCJAL3Rvb2xzL0NoYWluTWFuYWdlclwiO1xuLy8gaW1wb3J0IHR5cGUge1xuLy8gICBMZW5kT3B0aW9ucyxcbi8vICAgTGVuZFByb3ZpZGVyLFxuLy8gICBMZW5kVHJhbnNhY3Rpb24sXG4vLyAgIFRyYW5zYWN0aW9uRGF0YSxcbi8vIH0gZnJvbSBcIkAvdHlwZXMvbGVuZC5qc1wiO1xuaW1wb3J0IHsgdHlwZSBBc3NldElkZW50aWZpZXIsIHBhcnNlTGVuZFBhcmFtcyB9IGZyb20gXCJAL3V0aWxzL2Fzc2V0cy5qc1wiO1xuaW1wb3J0IHsgRW1iZWRkZWRXYWxsZXQgfSBmcm9tIFwiQC93YWxsZXQvYmFzZS93YWxsZXRzL0VtYmVkZGVkV2FsbGV0LmpzXCI7XG5pbXBvcnQgdHlwZSB7IFRyYW5zYWN0aW9uRGF0YSB9IGZyb20gXCJAL3R5cGVzL3RyYW5zYWN0aW9uXCI7XG5cbi8qKlxuICogUHJpdnkgd2FsbGV0IGltcGxlbWVudGF0aW9uXG4gKiBAZGVzY3JpcHRpb24gV2FsbGV0IGltcGxlbWVudGF0aW9uIHVzaW5nIFByaXZ5IHNlcnZpY2VcbiAqL1xuZXhwb3J0IGNsYXNzIFByaXZ5V2FsbGV0IGV4dGVuZHMgRW1iZWRkZWRXYWxsZXQge1xuICBwdWJsaWMgb3ZlcnJpZGUgd2FsbGV0SWQ6IHN0cmluZztcbiAgcHJpdmF0ZSBwcml2eUNsaWVudDogUHJpdnlDbGllbnQ7XG4gIHByaXZhdGUgY2hhaW5NYW5hZ2VyOiBDaGFpbk1hbmFnZXI7XG4gIC8vICAgcHJpdmF0ZSBsZW5kUHJvdmlkZXI6IExlbmRQcm92aWRlcjtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBQcml2eSB3YWxsZXQgcHJvdmlkZXJcbiAgICogQHBhcmFtIGFwcElkIC0gUHJpdnkgYXBwbGljYXRpb24gSURcbiAgICogQHBhcmFtIGFwcFNlY3JldCAtIFByaXZ5IGFwcGxpY2F0aW9uIHNlY3JldFxuICAgKiBAcGFyYW0gdmVyYnMgLSBWZXJicyBpbnN0YW5jZSBmb3IgYWNjZXNzaW5nIGNvbmZpZ3VyZWQgcHJvdmlkZXJzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2eUNsaWVudDogUHJpdnlDbGllbnQsXG4gICAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgICBhZGRyZXNzOiBBZGRyZXNzLFxuICAgIGNoYWluTWFuYWdlcjogQ2hhaW5NYW5hZ2VyXG4gICAgLy8gbGVuZFByb3ZpZGVyOiBMZW5kUHJvdmlkZXJcbiAgKSB7XG4gICAgc3VwZXIoYWRkcmVzcywgd2FsbGV0SWQpO1xuICAgIHRoaXMucHJpdnlDbGllbnQgPSBwcml2eUNsaWVudDtcbiAgICB0aGlzLndhbGxldElkID0gd2FsbGV0SWQ7XG4gICAgdGhpcy5jaGFpbk1hbmFnZXIgPSBjaGFpbk1hbmFnZXI7XG4gICAgLy8gdGhpcy5sZW5kUHJvdmlkZXIgPSBsZW5kUHJvdmlkZXI7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgTG9jYWxBY2NvdW50IGZyb20gdGhpcyBQcml2eSB3YWxsZXRcbiAgICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIHRoZSBQcml2eSB3YWxsZXQgaW50byBhIHZpZW0tY29tcGF0aWJsZSBMb2NhbEFjY291bnQgdGhhdCBjYW4gc2lnblxuICAgKiBtZXNzYWdlcyBhbmQgdHJhbnNhY3Rpb25zLiBUaGUgcmV0dXJuZWQgYWNjb3VudCB1c2VzIFByaXZ5J3Mgc2lnbmluZyBpbmZyYXN0cnVjdHVyZVxuICAgKiB1bmRlciB0aGUgaG9vZCB3aGlsZSBwcm92aWRpbmcgYSBzdGFuZGFyZCB2aWVtIGludGVyZmFjZS5cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBMb2NhbEFjY291bnQgY29uZmlndXJlZCBmb3Igc2lnbmluZyBvcGVyYXRpb25zXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgd2FsbGV0IHJldHJpZXZhbCBmYWlscyBvciBzaWduaW5nIG9wZXJhdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICovXG4gIGFzeW5jIGFjY291bnQoKTogUHJvbWlzZTxMb2NhbEFjY291bnQ+IHtcbiAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgY3JlYXRlVmllbUFjY291bnQoe1xuICAgICAgd2FsbGV0SWQ6IHRoaXMud2FsbGV0SWQsXG4gICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAvLyBUT0RPOiBGaXggdGhpcyB0eXBlIGVycm9yXG4gICAgICBwcml2eTogdGhpcy5wcml2eUNsaWVudCBhcyB1bmtub3duIGFzIEdldFZpZW1BY2NvdW50SW5wdXRUeXBlW1wicHJpdnlcIl0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgV2FsbGV0Q2xpZW50IGZvciB0aGlzIFByaXZ5IHdhbGxldFxuICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIHZpZW0tY29tcGF0aWJsZSBXYWxsZXRDbGllbnQgY29uZmlndXJlZCB3aXRoIHRoaXMgd2FsbGV0J3MgYWNjb3VudFxuICAgKiBhbmQgdGhlIHNwZWNpZmllZCBjaGFpbi4gVGhlIHJldHVybmVkIGNsaWVudCBjYW4gYmUgdXNlZCB0byBzZW5kIHRyYW5zYWN0aW9ucyBhbmQgaW50ZXJhY3RcbiAgICogd2l0aCBzbWFydCBjb250cmFjdHMgdXNpbmcgUHJpdnkncyBzaWduaW5nIGluZnJhc3RydWN0dXJlIHVuZGVyIHRoZSBob29kLlxuICAgKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBjaGFpbiBJRCB0byBjcmVhdGUgdGhlIHdhbGxldCBjbGllbnQgZm9yXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgV2FsbGV0Q2xpZW50IGNvbmZpZ3VyZWQgZm9yIHRoZSBzcGVjaWZpZWQgY2hhaW5cbiAgICogQHRocm93cyBFcnJvciBpZiBjaGFpbiBpcyBub3Qgc3VwcG9ydGVkIG9yIHdhbGxldCBjbGllbnQgY3JlYXRpb24gZmFpbHNcbiAgICovXG4gIGFzeW5jIHdhbGxldENsaWVudChjaGFpbklkOiBTdXBwb3J0ZWRDaGFpbklkKTogUHJvbWlzZTxXYWxsZXRDbGllbnQ+IHtcbiAgICBjb25zdCBhY2NvdW50ID0gYXdhaXQgdGhpcy5hY2NvdW50KCk7XG4gICAgcmV0dXJuIGNyZWF0ZVdhbGxldENsaWVudCh7XG4gICAgICBhY2NvdW50LFxuICAgICAgY2hhaW46IHRoaXMuY2hhaW5NYW5hZ2VyLmdldENoYWluKGNoYWluSWQpLFxuICAgICAgdHJhbnNwb3J0OiBodHRwKHRoaXMuY2hhaW5NYW5hZ2VyLmdldFJwY1VybChjaGFpbklkKSksXG4gICAgfSk7XG4gIH1cblxuICAvLyDimqDvuI8gIFdBUk5JTkc6IFRFQ0ggREVCVCBCRUxPVyDimqDvuI9cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBUaGUgbWV0aG9kcyBiZWxvdyB0aGlzIGNvbW1lbnQgYXJlIGxlZ2FjeSB0ZWNoIGRlYnQgZnJvbSB0aGUgUE9DXG4gIC8vIGFuZCB3aWxsIG1vc3QgbGlrZWx5IGJlIFJFTU9WRUQgaW4gYSBmdXR1cmUgcmVmYWN0b3IuXG4gIC8vXG4gIC8vIERPIE5PVCByZWx5IG9uIHRoZXNlIG1ldGhvZHMgaW4gcHJvZHVjdGlvbiBjb2RlIVxuICAvLyBETyBOT1QgZXh0ZW5kIG9yIG1vZGlmeSB0aGVzZSBtZXRob2RzIVxuICAvL1xuICAvLyBJZiB5b3UgbmVlZCB0aGlzIGZ1bmN0aW9uYWxpdHksIHBsZWFzZSBkaXNjdXNzIHdpdGggdGhlIHRlYW1cbiAgLy8gYmVmb3JlIHVzaW5nIG9yIGJ1aWxkaW5nIHVwb24gdGhlc2UgbWV0aG9kcy5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBMZW5kIGFzc2V0cyB0byBhIGxlbmRpbmcgbWFya2V0XG4gICAqIEBkZXNjcmlwdGlvbiBMZW5kcyBhc3NldHMgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgbGVuZGluZyBwcm92aWRlciB3aXRoIGh1bWFuLXJlYWRhYmxlIGFtb3VudHNcbiAgICogQHBhcmFtIGFtb3VudCAtIEh1bWFuLXJlYWRhYmxlIGFtb3VudCB0byBsZW5kIChlLmcuIDEuNSlcbiAgICogQHBhcmFtIGFzc2V0IC0gQXNzZXQgc3ltYm9sIChlLmcuICd1c2RjJykgb3IgdG9rZW4gYWRkcmVzc1xuICAgKiBAcGFyYW0gbWFya2V0SWQgLSBPcHRpb25hbCBzcGVjaWZpYyBtYXJrZXQgSUQgb3IgdmF1bHQgbmFtZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGxlbmRpbmcgY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBsZW5kaW5nIHRyYW5zYWN0aW9uIGRldGFpbHNcbiAgICogQHRocm93cyBFcnJvciBpZiBubyBsZW5kaW5nIHByb3ZpZGVyIGlzIGNvbmZpZ3VyZWRcbiAgICovXG4gIC8vICAgYXN5bmMgbGVuZChcbiAgLy8gICAgIGFtb3VudDogbnVtYmVyLFxuICAvLyAgICAgYXNzZXQ6IEFzc2V0SWRlbnRpZmllcixcbiAgLy8gICAgIG1hcmtldElkPzogc3RyaW5nLFxuICAvLyAgICAgb3B0aW9ucz86IExlbmRPcHRpb25zXG4gIC8vICAgKTogUHJvbWlzZTxMZW5kVHJhbnNhY3Rpb24+IHtcbiAgLy8gICAgIC8vIFBhcnNlIGh1bWFuLXJlYWRhYmxlIGlucHV0c1xuICAvLyAgICAgLy8gVE9ETzogR2V0IGFjdHVhbCBjaGFpbiBJRCBmcm9tIHdhbGxldCBjb250ZXh0LCBmb3Igbm93IHVzaW5nIFVuaWNoYWluXG4gIC8vICAgICBjb25zdCB7IGFtb3VudDogcGFyc2VkQW1vdW50LCBhc3NldDogcmVzb2x2ZWRBc3NldCB9ID0gcGFyc2VMZW5kUGFyYW1zKFxuICAvLyAgICAgICBhbW91bnQsXG4gIC8vICAgICAgIGFzc2V0LFxuICAvLyAgICAgICB1bmljaGFpbi5pZFxuICAvLyAgICAgKTtcblxuICAvLyAgICAgLy8gU2V0IHJlY2VpdmVyIHRvIHdhbGxldCBhZGRyZXNzIGlmIG5vdCBzcGVjaWZpZWRcbiAgLy8gICAgIGNvbnN0IGxlbmRPcHRpb25zOiBMZW5kT3B0aW9ucyA9IHtcbiAgLy8gICAgICAgLi4ub3B0aW9ucyxcbiAgLy8gICAgICAgcmVjZWl2ZXI6IG9wdGlvbnM/LnJlY2VpdmVyIHx8IHRoaXMuYWRkcmVzcyxcbiAgLy8gICAgIH07XG5cbiAgLy8gICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMubGVuZFByb3ZpZGVyLmRlcG9zaXQoXG4gIC8vICAgICAgIHJlc29sdmVkQXNzZXQuYWRkcmVzcyxcbiAgLy8gICAgICAgcGFyc2VkQW1vdW50LFxuICAvLyAgICAgICBtYXJrZXRJZCxcbiAgLy8gICAgICAgbGVuZE9wdGlvbnNcbiAgLy8gICAgICk7XG5cbiAgLy8gICAgIHJldHVybiByZXN1bHQ7XG4gIC8vICAgfVxuXG4gIC8qKlxuICAgKiBTaWduIGEgdHJhbnNhY3Rpb24gd2l0aG91dCBzZW5kaW5nIGl0XG4gICAqIEBkZXNjcmlwdGlvbiBTaWducyBhIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBjb25maWd1cmVkIHdhbGxldCBwcm92aWRlciBidXQgZG9lc24ndCBzZW5kIGl0XG4gICAqIEBwYXJhbSB0cmFuc2FjdGlvbkRhdGEgLSBUcmFuc2FjdGlvbiBkYXRhIHRvIHNpZ25cbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgd2FsbGV0IGlzIG5vdCBpbml0aWFsaXplZCBvciBubyB3YWxsZXQgcHJvdmlkZXIgaXMgY29uZmlndXJlZFxuICAgKi9cbiAgYXN5bmMgc2lnbih0cmFuc2FjdGlvbkRhdGE6IFRyYW5zYWN0aW9uRGF0YSk6IFByb21pc2U8YDB4JHtzdHJpbmd9YD4ge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5zaWduT25seSh0cmFuc2FjdGlvbkRhdGEpKSBhcyBgMHgke3N0cmluZ31gO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYSB0cmFuc2FjdGlvbiB3aXRob3V0IHNlbmRpbmcgaXRcbiAgICogQGRlc2NyaXB0aW9uIFNpZ25zIGEgdHJhbnNhY3Rpb24gdXNpbmcgUHJpdnkncyB3YWxsZXQgQVBJIGJ1dCBkb2Vzbid0IHNlbmQgaXRcbiAgICogQHBhcmFtIHdhbGxldElkIC0gV2FsbGV0IElEIHRvIHVzZSBmb3Igc2lnbmluZ1xuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25EYXRhIC0gVHJhbnNhY3Rpb24gZGF0YSB0byBzaWduXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRyYW5zYWN0aW9uIHNpZ25pbmcgZmFpbHNcbiAgICovXG4gIGFzeW5jIHNpZ25Pbmx5KHRyYW5zYWN0aW9uRGF0YTogVHJhbnNhY3Rpb25EYXRhKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJpdnlXYWxsZXQgPSBhd2FpdCB0aGlzLnByaXZ5Q2xpZW50LndhbGxldEFwaS5nZXRXYWxsZXQoe1xuICAgICAgICBpZDogdGhpcy53YWxsZXRJZCxcbiAgICAgIH0pO1xuICAgICAgLy8gR2V0IHB1YmxpYyBjbGllbnQgZm9yIGdhcyBlc3RpbWF0aW9uXG4gICAgICBjb25zdCBwdWJsaWNDbGllbnQgPSB0aGlzLmNoYWluTWFuYWdlci5nZXRQdWJsaWNDbGllbnQodW5pY2hhaW4uaWQpOyAvLyBVbmljaGFpblxuXG4gICAgICAvLyBFc3RpbWF0ZSBnYXMgbGltaXRcbiAgICAgIGNvbnN0IGdhc0xpbWl0ID0gYXdhaXQgcHVibGljQ2xpZW50LmVzdGltYXRlR2FzKHtcbiAgICAgICAgYWNjb3VudDogcHJpdnlXYWxsZXQuYWRkcmVzcyBhcyBBZGRyZXNzLFxuICAgICAgICB0bzogdHJhbnNhY3Rpb25EYXRhLnRvLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbkRhdGEuZGF0YSBhcyBgMHgke3N0cmluZ31gLFxuICAgICAgICB2YWx1ZTogQmlnSW50KHRyYW5zYWN0aW9uRGF0YS52YWx1ZSksXG4gICAgICB9KTtcblxuICAgICAgLy8gR2V0IGN1cnJlbnQgZ2FzIHByaWNlIGFuZCBmZWUgZGF0YVxuICAgICAgY29uc3QgZmVlRGF0YSA9IGF3YWl0IHB1YmxpY0NsaWVudC5lc3RpbWF0ZUZlZXNQZXJHYXMoKTtcblxuICAgICAgLy8gR2V0IGN1cnJlbnQgbm9uY2UgZm9yIHRoZSB3YWxsZXQgLSBtYW51YWwgbWFuYWdlbWVudCBzaW5jZSBQcml2eSBpc24ndCBoYW5kbGluZyBpdCBwcm9wZXJseVxuICAgICAgY29uc3Qgbm9uY2UgPSBhd2FpdCBwdWJsaWNDbGllbnQuZ2V0VHJhbnNhY3Rpb25Db3VudCh7XG4gICAgICAgIGFkZHJlc3M6IHByaXZ5V2FsbGV0LmFkZHJlc3MgYXMgQWRkcmVzcyxcbiAgICAgICAgYmxvY2tUYWc6IFwicGVuZGluZ1wiLCAvLyBVc2UgcGVuZGluZyB0byBnZXQgdGhlIG5leHQgbm9uY2UgaW5jbHVkaW5nIGFueSBwZW5kaW5nIHR4c1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjY29yZGluZyB0byBQcml2eSBkb2NzOiBpZiB5b3UgcHJvdmlkZSBBTlkgZ2FzIHBhcmFtZXRlcnMsIHlvdSBtdXN0IHByb3ZpZGUgQUxMIG9mIHRoZW1cbiAgICAgIGNvbnN0IHR4UGFyYW1zOiBhbnkgPSB7XG4gICAgICAgIHRvOiB0cmFuc2FjdGlvbkRhdGEudG8sXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uRGF0YS5kYXRhIGFzIGAweCR7c3RyaW5nfWAsXG4gICAgICAgIHZhbHVlOiB0cmFuc2FjdGlvbkRhdGEudmFsdWUsXG4gICAgICAgIGNoYWluSWQ6IDEzMCwgLy8gVW5pY2hhaW5cbiAgICAgICAgdHlwZTogMiwgLy8gRUlQLTE1NTlcbiAgICAgICAgZ2FzTGltaXQ6IGAweCR7Z2FzTGltaXQudG9TdHJpbmcoMTYpfWAsXG4gICAgICAgIG1heEZlZVBlckdhczogYDB4JHsoZmVlRGF0YS5tYXhGZWVQZXJHYXMgfHwgQmlnSW50KDEwMDAwMDAwMDApKS50b1N0cmluZygxNil9YCwgLy8gZmFsbGJhY2sgdG8gMSBnd2VpXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBgMHgkeyhmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IEJpZ0ludCgxMDAwMDAwMDApKS50b1N0cmluZygxNil9YCwgLy8gZmFsbGJhY2sgdG8gMC4xIGd3ZWlcbiAgICAgICAgbm9uY2U6IGAweCR7bm9uY2UudG9TdHJpbmcoMTYpfWAsIC8vIEV4cGxpY2l0bHkgcHJvdmlkZSB0aGUgY29ycmVjdCBub25jZVxuICAgICAgfTtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBbUFJJVllfUFJPVklERVJdIENvbXBsZXRlIHR4IHBhcmFtcyAtIFR5cGU6ICR7dHhQYXJhbXMudHlwZX0sIE5vbmNlOiAke25vbmNlfSwgTGltaXQ6ICR7Z2FzTGltaXR9LCBNYXhGZWU6ICR7ZmVlRGF0YS5tYXhGZWVQZXJHYXMgfHwgXCJmYWxsYmFja1wifSwgUHJpb3JpdHk6ICR7ZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCBcImZhbGxiYWNrXCJ9YFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPVxuICAgICAgICBhd2FpdCB0aGlzLnByaXZ5Q2xpZW50LndhbGxldEFwaS5ldGhlcmV1bS5zaWduVHJhbnNhY3Rpb24oe1xuICAgICAgICAgIHdhbGxldElkOiB0aGlzLndhbGxldElkLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eFBhcmFtcyxcbiAgICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5zaWduZWRUcmFuc2FjdGlvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHNpZ24gdHJhbnNhY3Rpb24gZm9yIHdhbGxldCAke3RoaXMud2FsbGV0SWR9OiAke1xuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQGRlc2NyaXB0aW9uIFNlbmRzIGEgcHJlLXNpZ25lZCB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29ya1xuICAgKiBAcGFyYW0gc2lnbmVkVHJhbnNhY3Rpb24gLSBTaWduZWQgdHJhbnNhY3Rpb24gdG8gc2VuZFxuICAgKiBAcGFyYW0gcHVibGljQ2xpZW50IC0gVmllbSBwdWJsaWMgY2xpZW50IHRvIHNlbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRyYW5zYWN0aW9uIGhhc2hcbiAgICovXG4gIGFzeW5jIHNlbmQoc2lnbmVkVHJhbnNhY3Rpb246IHN0cmluZywgcHVibGljQ2xpZW50OiBhbnkpOiBQcm9taXNlPEhhc2g+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHB1YmxpY0NsaWVudC5zZW5kUmF3VHJhbnNhY3Rpb24oe1xuICAgICAgICBzZXJpYWxpemVkVHJhbnNhY3Rpb246IHNpZ25lZFRyYW5zYWN0aW9uIGFzIGAweCR7c3RyaW5nfWAsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gc2VuZCB0cmFuc2FjdGlvbjogJHtcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBBZGRyZXNzLCBMb2NhbEFjY291bnQsIFdhbGxldENsaWVudCB9IGZyb20gXCJ2aWVtXCI7XG5cbmltcG9ydCB0eXBlIHsgU3VwcG9ydGVkQ2hhaW5JZCB9IGZyb20gXCJAL2NvbnN0YW50cy9jaGFpbnNcIjtcblxuLyoqXG4gKiBCYXNlIGVtYmVkZGVkIHdhbGxldCBjbGFzc1xuICogQGRlc2NyaXB0aW9uIEFic3RyYWN0IGJhc2UgY2xhc3MgZm9yIGVtYmVkZGVkIHdhbGxldCBpbXBsZW1lbnRhdGlvbnMgKFByaXZ5LCBEeW5hbWljLCBldGMuKS5cbiAqIFByb3ZpZGVzIGEgc3RhbmRhcmQgaW50ZXJmYWNlIGZvciBlbWJlZGRlZCB3YWxsZXRzIHRoYXQgY2FuIGJlIHVzZWQgYXMgc2lnbmVycyBmb3Igc21hcnQgd2FsbGV0cy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEVtYmVkZGVkV2FsbGV0IHtcbiAgLyoqIFRoZSB3YWxsZXQncyBFdGhlcmV1bSBhZGRyZXNzICovXG4gIHB1YmxpYyByZWFkb25seSBhZGRyZXNzOiBBZGRyZXNzO1xuXG4gIHB1YmxpYyByZWFkb25seSB3YWxsZXRJZD86IHN0cmluZztcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGVtYmVkZGVkIHdhbGxldCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSB3YWxsZXQncyBFdGhlcmV1bSBhZGRyZXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzOiBBZGRyZXNzLCB3YWxsZXRJZD86IHN0cmluZykge1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy53YWxsZXRJZCA9IHdhbGxldElkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhY2NvdW50IGZvciB0aGlzIGVtYmVkZGVkIHdhbGxldFxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIExvY2FsQWNjb3VudCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNpZ24gdHJhbnNhY3Rpb25zIGFuZCBtZXNzYWdlcy5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCBhcyB0aGUgYWNjb3VudCBmb3Igc21hcnQgd2FsbGV0IG9wZXJhdGlvbnMgaWYgdGhlIGVtYmVkZGVkIHdhbGxldCBpcyBhblxuICAgKiBvd25lciBvbiB0aGUgc21hcnQgd2FsbGV0LlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIExvY2FsQWNjb3VudCBjb25maWd1cmVkIGZvciBzaWduaW5nIG9wZXJhdGlvbnNcbiAgICovXG4gIGFic3RyYWN0IGFjY291bnQoKTogUHJvbWlzZTxMb2NhbEFjY291bnQ+O1xuXG4gIC8qKlxuICAgKiBHZXQgYSB3YWxsZXQgY2xpZW50IGZvciB0aGlzIGVtYmVkZGVkIHdhbGxldFxuICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIFdhbGxldENsaWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNlbmQgdHJhbnNhY3Rpb25zIGFuZCBpbnRlcmFjdFxuICAgKiB3aXRoIHNtYXJ0IGNvbnRyYWN0cy5cbiAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgY2hhaW4gSUQgdG8gY3JlYXRlIHRoZSB3YWxsZXQgY2xpZW50IGZvclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIFdhbGxldENsaWVudCBjb25maWd1cmVkIGZvciB0aGUgc3BlY2lmaWVkIGNoYWluXG4gICAqL1xuICBhYnN0cmFjdCB3YWxsZXRDbGllbnQoY2hhaW5JZDogU3VwcG9ydGVkQ2hhaW5JZCk6IFByb21pc2U8V2FsbGV0Q2xpZW50Pjtcbn1cbiIsImltcG9ydCB0eXBlIHsgRW1iZWRkZWRXYWxsZXQgfSBmcm9tIFwiQC93YWxsZXQvYmFzZS93YWxsZXRzL0VtYmVkZGVkV2FsbGV0XCI7XG5cbi8qKlxuICogQmFzZSBlbWJlZGRlZCB3YWxsZXQgcHJvdmlkZXIgY2xhc3NcbiAqIEBkZXNjcmlwdGlvbiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBlbWJlZGRlZCB3YWxsZXQgcHJvdmlkZXIgaW1wbGVtZW50YXRpb25zIChQcml2eSwgRHluYW1pYywgZXRjLikuXG4gKiBQcm92aWRlcyBhIHN0YW5kYXJkIGludGVyZmFjZSBmb3IgY3JlYXRpbmcgYW5kIHJldHJpZXZpbmcgZW1iZWRkZWQgd2FsbGV0cyB0aGF0IGNhbiBiZSB1c2VkXG4gKiBhcyBzaWduZXJzIGZvciBzbWFydCB3YWxsZXRzIG9yIHN0YW5kYWxvbmUgd2FsbGV0IGZ1bmN0aW9uYWxpdHkuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBFbWJlZGRlZFdhbGxldFByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBlbWJlZGRlZCB3YWxsZXRcbiAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBuZXcgZW1iZWRkZWQgd2FsbGV0IGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlcidzIGluZnJhc3RydWN0dXJlLlxuICAgKiBUaGUgd2FsbGV0IHdpbGwgYmUgcmVhZHkgdG8gdXNlIGZvciBzaWduaW5nIHRyYW5zYWN0aW9ucyBhbmQgbWVzc2FnZXMuXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgbmV3IGVtYmVkZGVkIHdhbGxldCBpbnN0YW5jZVxuICAgKi9cbiAgYWJzdHJhY3QgY3JlYXRlV2FsbGV0KCk6IFByb21pc2U8RW1iZWRkZWRXYWxsZXQ+O1xuXG4gIC8qKlxuICAgKiBHZXQgYW4gZXhpc3RpbmcgZW1iZWRkZWQgd2FsbGV0IGJ5IElEXG4gICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgYW4gZXhpc3RpbmcgZW1iZWRkZWQgd2FsbGV0IHVzaW5nIGl0cyB1bmlxdWUgaWRlbnRpZmllci5cbiAgICogVGhlIHdhbGxldCBtdXN0IGhhdmUgYmVlbiBwcmV2aW91c2x5IGNyZWF0ZWQgdGhyb3VnaCB0aGlzIHByb3ZpZGVyLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gV2FsbGV0IHJldHJpZXZhbCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0SWQgLSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGVtYmVkZGVkIHdhbGxldFxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZXhpc3RpbmcgZW1iZWRkZWQgd2FsbGV0IGluc3RhbmNlXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgd2FsbGV0IHdpdGggdGhlIHNwZWNpZmllZCBJRCBpcyBub3QgZm91bmRcbiAgICovXG4gIGFic3RyYWN0IGdldFdhbGxldChwYXJhbXM6IHsgd2FsbGV0SWQ6IHN0cmluZyB9KTogUHJvbWlzZTxFbWJlZGRlZFdhbGxldD47XG59XG4iXSwibmFtZXMiOlsidW5pY2hhaW4iLCJwYWQiLCJlcmMyMEFiaSIsImFkZHJlc3MiLCJ0b2tlbkluZm8iLCJwYXJzZWRBbW91bnQiLCJodHRwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../sdk/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./src/app/api/sdk/create-wallet/route.ts":
/*!************************************************!*\
  !*** ./src/app/api/sdk/create-wallet/route.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/../../node_modules/next/dist/api/server.js\");\n/* harmony import */ var _libs_MyceliumService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/libs/MyceliumService */ \"(rsc)/./src/libs/MyceliumService.ts\");\n/* harmony import */ var _libs_WalletDatabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/libs/WalletDatabase */ \"(rsc)/./src/libs/WalletDatabase.ts\");\n\n\n\nasync function POST(request) {\n    try {\n        const { userId } = await request.json();\n        if (!userId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"User ID is required\"\n            }, {\n                status: 400\n            });\n        }\n        const walletDb = _libs_WalletDatabase__WEBPACK_IMPORTED_MODULE_2__.WalletDatabase.getInstance();\n        await walletDb.init();\n        const myceliumService = _libs_MyceliumService__WEBPACK_IMPORTED_MODULE_1__.MyceliumService.getInstance();\n        await myceliumService.init();\n        const result = await myceliumService.createWallet();\n        await walletDb.saveWallet(userId, result.walletId, result.walletAddress);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            walletId: result.walletId,\n            walletAddress: result.walletAddress,\n            success: true\n        });\n    } catch (error) {\n        console.error(\"Error creating wallet:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: `Failed to create wallet: ${error}`\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9zZGsvY3JlYXRlLXdhbGxldC9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdEO0FBQ0M7QUFDRjtBQUVoRCxlQUFlRyxLQUFLQyxPQUFvQjtJQUM3QyxJQUFJO1FBQ0YsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBRyxNQUFNRCxRQUFRRSxJQUFJO1FBRXJDLElBQUksQ0FBQ0QsUUFBUTtZQUNYLE9BQU9MLHFEQUFZQSxDQUFDTSxJQUFJLENBQ3RCO2dCQUFFQyxPQUFPO1lBQXNCLEdBQy9CO2dCQUFFQyxRQUFRO1lBQUk7UUFFbEI7UUFFQSxNQUFNQyxXQUFXUCxnRUFBY0EsQ0FBQ1EsV0FBVztRQUMzQyxNQUFNRCxTQUFTRSxJQUFJO1FBRW5CLE1BQU1DLGtCQUFrQlgsa0VBQWVBLENBQUNTLFdBQVc7UUFDbkQsTUFBTUUsZ0JBQWdCRCxJQUFJO1FBRTFCLE1BQU1FLFNBQVMsTUFBTUQsZ0JBQWdCRSxZQUFZO1FBRWpELE1BQU1MLFNBQVNNLFVBQVUsQ0FBQ1YsUUFBUVEsT0FBT0csUUFBUSxFQUFFSCxPQUFPSSxhQUFhO1FBRXZFLE9BQU9qQixxREFBWUEsQ0FBQ00sSUFBSSxDQUFDO1lBQ3ZCVSxVQUFVSCxPQUFPRyxRQUFRO1lBQ3pCQyxlQUFlSixPQUFPSSxhQUFhO1lBQ25DQyxTQUFTO1FBQ1g7SUFDRixFQUFFLE9BQU9YLE9BQU87UUFDZFksUUFBUVosS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsT0FBT1AscURBQVlBLENBQUNNLElBQUksQ0FDdEI7WUFBRUMsT0FBTyxDQUFDLHlCQUF5QixFQUFFQSxPQUFPO1FBQUMsR0FDN0M7WUFBRUMsUUFBUTtRQUFJO0lBRWxCO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL2Zyb250ZW5kL3NyYy9hcHAvYXBpL3Nkay9jcmVhdGUtd2FsbGV0L3JvdXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tIFwibmV4dC9zZXJ2ZXJcIjtcbmltcG9ydCB7IE15Y2VsaXVtU2VydmljZSB9IGZyb20gXCJAL2xpYnMvTXljZWxpdW1TZXJ2aWNlXCI7XG5pbXBvcnQgeyBXYWxsZXREYXRhYmFzZSB9IGZyb20gXCJAL2xpYnMvV2FsbGV0RGF0YWJhc2VcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG5cbiAgICBpZiAoIXVzZXJJZCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiBcIlVzZXIgSUQgaXMgcmVxdWlyZWRcIiB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgd2FsbGV0RGIgPSBXYWxsZXREYXRhYmFzZS5nZXRJbnN0YW5jZSgpO1xuICAgIGF3YWl0IHdhbGxldERiLmluaXQoKTtcblxuICAgIGNvbnN0IG15Y2VsaXVtU2VydmljZSA9IE15Y2VsaXVtU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgIGF3YWl0IG15Y2VsaXVtU2VydmljZS5pbml0KCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBteWNlbGl1bVNlcnZpY2UuY3JlYXRlV2FsbGV0KCk7XG5cbiAgICBhd2FpdCB3YWxsZXREYi5zYXZlV2FsbGV0KHVzZXJJZCwgcmVzdWx0LndhbGxldElkLCByZXN1bHQud2FsbGV0QWRkcmVzcyk7XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgd2FsbGV0SWQ6IHJlc3VsdC53YWxsZXRJZCxcbiAgICAgIHdhbGxldEFkZHJlc3M6IHJlc3VsdC53YWxsZXRBZGRyZXNzLFxuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY3JlYXRpbmcgd2FsbGV0OlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogYEZhaWxlZCB0byBjcmVhdGUgd2FsbGV0OiAke2Vycm9yfWAgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJOZXh0UmVzcG9uc2UiLCJNeWNlbGl1bVNlcnZpY2UiLCJXYWxsZXREYXRhYmFzZSIsIlBPU1QiLCJyZXF1ZXN0IiwidXNlcklkIiwianNvbiIsImVycm9yIiwic3RhdHVzIiwid2FsbGV0RGIiLCJnZXRJbnN0YW5jZSIsImluaXQiLCJteWNlbGl1bVNlcnZpY2UiLCJyZXN1bHQiLCJjcmVhdGVXYWxsZXQiLCJzYXZlV2FsbGV0Iiwid2FsbGV0SWQiLCJ3YWxsZXRBZGRyZXNzIiwic3VjY2VzcyIsImNvbnNvbGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/sdk/create-wallet/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/libs/MyceliumService.ts":
/*!*************************************!*\
  !*** ./src/libs/MyceliumService.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MyceliumService: () => (/* binding */ MyceliumService),\n/* harmony export */   myceliumService: () => (/* binding */ myceliumService)\n/* harmony export */ });\n/* harmony import */ var _mycelium_sdk_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mycelium-sdk/core */ \"(rsc)/../sdk/dist/index.js\");\n/* harmony import */ var viem_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! viem/chains */ \"(rsc)/../../node_modules/viem/_esm/chains/definitions/sepolia.js\");\n\n\nclass MyceliumService {\n    constructor(){\n        this.sdk = null;\n        this.initialized = false;\n    }\n    static getInstance() {\n        if (!MyceliumService.instance) {\n            MyceliumService.instance = new MyceliumService();\n        }\n        return MyceliumService.instance;\n    }\n    async init() {\n        if (this.initialized) return;\n        try {\n            this.sdk = new _mycelium_sdk_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n                walletsConfig: {\n                    embeddedWalletConfig: {\n                        provider: {\n                            type: \"privy\",\n                            providerConfig: {\n                                appId: \"cm6ph1njd02e8cy7y6vti8lp1\",\n                                appSecret: \"2dfBFkb5Rn55sZrRbHLFrP1omdoon51pCgqGUGbmfkuqDnh2uoxHQ5ig5MLvEB2T4rXzd1DF92G4rQBNGfV8EpUA\"\n                            }\n                        }\n                    },\n                    smartWalletConfig: {\n                        provider: {\n                            type: \"default\"\n                        }\n                    }\n                },\n                chains: [\n                    {\n                        chainId: viem_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia.id,\n                        rpcUrl: viem_chains__WEBPACK_IMPORTED_MODULE_1__.sepolia.rpcUrls.default.http[0],\n                        bundlerUrl: \"https://rpc.zerodev.app/api/v3/82e47083-d513-4948-b013-bacce477bb1d/chain/11155111\"\n                    }\n                ]\n            });\n            this.initialized = true;\n            console.log(\"MyceliumService initialized\");\n        } catch (error) {\n            throw new Error(`Failed to initialize MyceliumService: ${error}`);\n        }\n    }\n    async createWallet() {\n        if (!this.sdk) {\n            throw new Error(\"SDK not initialized\");\n        }\n        const embeddedWallet = await this.sdk.wallet.createEmbeddedWallet();\n        const embeddedWalletId = embeddedWallet.walletId;\n        console.log(\"Embedded wallet ID: \", embeddedWalletId);\n        const wallet = await this.sdk.wallet.createSmartWallet({\n            owners: [\n                embeddedWallet.address\n            ],\n            signer: await embeddedWallet.account()\n        });\n        return {\n            walletId: embeddedWalletId,\n            walletAddress: await wallet.getAddress()\n        };\n    }\n    async getWallet(existingWallet) {\n        if (!this.sdk) {\n            throw new Error(\"SDK not initialized\");\n        }\n        const wallet = await this.sdk.wallet.getSmartWalletWithEmbeddedSigner({\n            walletId: existingWallet.wallet_id\n        });\n        return wallet;\n    }\n    async getWalletBalance(walletId) {\n        if (!this.sdk) {\n            throw new Error(\"SDK not initialized\");\n        }\n        const wallet = await this.sdk.wallet.getSmartWalletWithEmbeddedSigner({\n            walletId\n        });\n        const tokens = await wallet.getBalance();\n        return tokens.map((token)=>{\n            return {\n                symbol: token.symbol,\n                balance: token.totalBalance,\n                formattedBalance: token.totalFormattedBalance\n            };\n        });\n    }\n    //   async sendTransaction(walletId: string, transaction: any) {\n    //     if (!this.sdk) {\n    //       throw new Error(\"SDK not initialized\");\n    //     }\n    //     const wallet = await this.sdk.wallet.getSmartWalletWithEmbeddedSigner({\n    //       walletId,\n    //     });\n    //     return await wallet.sendTransaction(transaction);\n    //   }\n    getSDK() {\n        return this.sdk;\n    }\n}\nconst myceliumService = MyceliumService.getInstance();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxnRUFBZ0U7SUFDaEUsdUJBQXVCO0lBQ3ZCLGdEQUFnRDtJQUNoRCxRQUFRO0lBRVIsOEVBQThFO0lBQzlFLGtCQUFrQjtJQUNsQixVQUFVO0lBRVYsd0RBQXdEO0lBQ3hELE1BQU07SUFFTkMsU0FBNkI7UUFDM0IsT0FBTyxJQUFJLENBQUN6RCxHQUFHO0lBQ2pCO0FBQ0Y7QUFFTyxNQUFNMEQsa0JBQWtCM0QsZ0JBQWdCRyxXQUFXLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL2Zyb250ZW5kL3NyYy9saWJzL015Y2VsaXVtU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTXljZWxpdW1TREsgZnJvbSBcIkBteWNlbGl1bS1zZGsvY29yZVwiO1xuaW1wb3J0IHsgc2Vwb2xpYSB9IGZyb20gXCJ2aWVtL2NoYWluc1wiO1xuaW1wb3J0IHR5cGUgeyBXYWxsZXRSZWNvcmQgfSBmcm9tIFwiLi9XYWxsZXREYXRhYmFzZVwiO1xuaW1wb3J0IHR5cGUgeyBTbWFydFdhbGxldCwgVG9rZW5CYWxhbmNlIH0gZnJvbSBcIkBteWNlbGl1bS1zZGsvY29yZVwiO1xuXG5leHBvcnQgY2xhc3MgTXljZWxpdW1TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IE15Y2VsaXVtU2VydmljZTtcbiAgcHJpdmF0ZSBzZGs6IE15Y2VsaXVtU0RLIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogTXljZWxpdW1TZXJ2aWNlIHtcbiAgICBpZiAoIU15Y2VsaXVtU2VydmljZS5pbnN0YW5jZSkge1xuICAgICAgTXljZWxpdW1TZXJ2aWNlLmluc3RhbmNlID0gbmV3IE15Y2VsaXVtU2VydmljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gTXljZWxpdW1TZXJ2aWNlLmluc3RhbmNlO1xuICB9XG5cbiAgYXN5bmMgaW5pdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc2RrID0gbmV3IE15Y2VsaXVtU0RLKHtcbiAgICAgICAgd2FsbGV0c0NvbmZpZzoge1xuICAgICAgICAgIGVtYmVkZGVkV2FsbGV0Q29uZmlnOiB7XG4gICAgICAgICAgICBwcm92aWRlcjoge1xuICAgICAgICAgICAgICB0eXBlOiBcInByaXZ5XCIsXG4gICAgICAgICAgICAgIHByb3ZpZGVyQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgYXBwSWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1BSSVZZX0FQUF9JRCEsXG4gICAgICAgICAgICAgICAgYXBwU2VjcmV0OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19QUklWWV9BUFBfU0VDUkVUISxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzbWFydFdhbGxldENvbmZpZzoge1xuICAgICAgICAgICAgcHJvdmlkZXI6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNoYWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoYWluSWQ6IHNlcG9saWEuaWQsXG4gICAgICAgICAgICBycGNVcmw6IHNlcG9saWEucnBjVXJscy5kZWZhdWx0Lmh0dHBbMF0sXG4gICAgICAgICAgICBidW5kbGVyVXJsOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CVU5ETEVSX1VSTCEsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKFwiTXljZWxpdW1TZXJ2aWNlIGluaXRpYWxpemVkXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBpbml0aWFsaXplIE15Y2VsaXVtU2VydmljZTogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjcmVhdGVXYWxsZXQoKSB7XG4gICAgaWYgKCF0aGlzLnNkaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU0RLIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gICAgY29uc3QgZW1iZWRkZWRXYWxsZXQgPSBhd2FpdCB0aGlzLnNkay53YWxsZXQuY3JlYXRlRW1iZWRkZWRXYWxsZXQoKTtcbiAgICBjb25zdCBlbWJlZGRlZFdhbGxldElkID0gZW1iZWRkZWRXYWxsZXQud2FsbGV0SWQgYXMgc3RyaW5nO1xuICAgIGNvbnNvbGUubG9nKFwiRW1iZWRkZWQgd2FsbGV0IElEOiBcIiwgZW1iZWRkZWRXYWxsZXRJZCk7XG5cbiAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCB0aGlzLnNkay53YWxsZXQuY3JlYXRlU21hcnRXYWxsZXQoe1xuICAgICAgb3duZXJzOiBbZW1iZWRkZWRXYWxsZXQuYWRkcmVzc10sXG4gICAgICBzaWduZXI6IGF3YWl0IGVtYmVkZGVkV2FsbGV0LmFjY291bnQoKSxcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICB3YWxsZXRJZDogZW1iZWRkZWRXYWxsZXRJZCxcbiAgICAgIHdhbGxldEFkZHJlc3M6IGF3YWl0IHdhbGxldC5nZXRBZGRyZXNzKCksXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFdhbGxldChleGlzdGluZ1dhbGxldDogV2FsbGV0UmVjb3JkKTogUHJvbWlzZTxTbWFydFdhbGxldD4ge1xuICAgIGlmICghdGhpcy5zZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNESyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgdGhpcy5zZGsud2FsbGV0LmdldFNtYXJ0V2FsbGV0V2l0aEVtYmVkZGVkU2lnbmVyKHtcbiAgICAgIHdhbGxldElkOiBleGlzdGluZ1dhbGxldC53YWxsZXRfaWQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gd2FsbGV0O1xuICB9XG5cbiAgYXN5bmMgZ2V0V2FsbGV0QmFsYW5jZShcbiAgICB3YWxsZXRJZDogc3RyaW5nXG4gICk6IFByb21pc2U8eyBzeW1ib2w6IHN0cmluZzsgYmFsYW5jZTogYmlnaW50OyBmb3JtYXR0ZWRCYWxhbmNlOiBzdHJpbmcgfVtdPiB7XG4gICAgaWYgKCF0aGlzLnNkaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU0RLIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCB0aGlzLnNkay53YWxsZXQuZ2V0U21hcnRXYWxsZXRXaXRoRW1iZWRkZWRTaWduZXIoe1xuICAgICAgd2FsbGV0SWQsXG4gICAgfSk7XG5cbiAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCB3YWxsZXQuZ2V0QmFsYW5jZSgpO1xuICAgIHJldHVybiB0b2tlbnMubWFwKCh0b2tlbikgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wsXG4gICAgICAgIGJhbGFuY2U6IHRva2VuLnRvdGFsQmFsYW5jZSxcbiAgICAgICAgZm9ybWF0dGVkQmFsYW5jZTogdG9rZW4udG90YWxGb3JtYXR0ZWRCYWxhbmNlLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHdhbGxldElkOiBzdHJpbmcsIHRyYW5zYWN0aW9uOiBhbnkpIHtcbiAgLy8gICAgIGlmICghdGhpcy5zZGspIHtcbiAgLy8gICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU0RLIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgLy8gICAgIH1cblxuICAvLyAgICAgY29uc3Qgd2FsbGV0ID0gYXdhaXQgdGhpcy5zZGsud2FsbGV0LmdldFNtYXJ0V2FsbGV0V2l0aEVtYmVkZGVkU2lnbmVyKHtcbiAgLy8gICAgICAgd2FsbGV0SWQsXG4gIC8vICAgICB9KTtcblxuICAvLyAgICAgcmV0dXJuIGF3YWl0IHdhbGxldC5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAvLyAgIH1cblxuICBnZXRTREsoKTogTXljZWxpdW1TREsgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5zZGs7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG15Y2VsaXVtU2VydmljZSA9IE15Y2VsaXVtU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuIl0sIm5hbWVzIjpbIk15Y2VsaXVtU0RLIiwic2Vwb2xpYSIsIk15Y2VsaXVtU2VydmljZSIsInNkayIsImluaXRpYWxpemVkIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImluaXQiLCJ3YWxsZXRzQ29uZmlnIiwiZW1iZWRkZWRXYWxsZXRDb25maWciLCJwcm92aWRlciIsInR5cGUiLCJwcm92aWRlckNvbmZpZyIsImFwcElkIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1BSSVZZX0FQUF9JRCIsImFwcFNlY3JldCIsIk5FWFRfUFVCTElDX1BSSVZZX0FQUF9TRUNSRVQiLCJzbWFydFdhbGxldENvbmZpZyIsImNoYWlucyIsImNoYWluSWQiLCJpZCIsInJwY1VybCIsInJwY1VybHMiLCJkZWZhdWx0IiwiaHR0cCIsImJ1bmRsZXJVcmwiLCJORVhUX1BVQkxJQ19CVU5ETEVSX1VSTCIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsIkVycm9yIiwiY3JlYXRlV2FsbGV0IiwiZW1iZWRkZWRXYWxsZXQiLCJ3YWxsZXQiLCJjcmVhdGVFbWJlZGRlZFdhbGxldCIsImVtYmVkZGVkV2FsbGV0SWQiLCJ3YWxsZXRJZCIsImNyZWF0ZVNtYXJ0V2FsbGV0Iiwib3duZXJzIiwiYWRkcmVzcyIsInNpZ25lciIsImFjY291bnQiLCJ3YWxsZXRBZGRyZXNzIiwiZ2V0QWRkcmVzcyIsImdldFdhbGxldCIsImV4aXN0aW5nV2FsbGV0IiwiZ2V0U21hcnRXYWxsZXRXaXRoRW1iZWRkZWRTaWduZXIiLCJ3YWxsZXRfaWQiLCJnZXRXYWxsZXRCYWxhbmNlIiwidG9rZW5zIiwiZ2V0QmFsYW5jZSIsIm1hcCIsInRva2VuIiwic3ltYm9sIiwiYmFsYW5jZSIsInRvdGFsQmFsYW5jZSIsImZvcm1hdHRlZEJhbGFuY2UiLCJ0b3RhbEZvcm1hdHRlZEJhbGFuY2UiLCJnZXRTREsiLCJteWNlbGl1bVNlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/libs/MyceliumService.ts\n");

/***/ }),

/***/ "(rsc)/./src/libs/WalletDatabase.ts":
/*!************************************!*\
  !*** ./src/libs/WalletDatabase.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletDatabase: () => (/* binding */ WalletDatabase),\n/* harmony export */   walletDB: () => (/* binding */ walletDB)\n/* harmony export */ });\n/* harmony import */ var sqlite3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sqlite3 */ \"sqlite3\");\n/* harmony import */ var sqlite3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sqlite3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sqlite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sqlite */ \"(rsc)/../../node_modules/sqlite/build/index.mjs\");\n\n\nclass WalletDatabase {\n    constructor(){\n        this.db = null;\n        this.initialized = false;\n    }\n    static getInstance() {\n        if (!WalletDatabase.instance) {\n            WalletDatabase.instance = new WalletDatabase();\n        }\n        return WalletDatabase.instance;\n    }\n    async init() {\n        if (this.initialized) return;\n        try {\n            this.db = await (0,sqlite__WEBPACK_IMPORTED_MODULE_1__.open)({\n                filename: \"./wallets.db\",\n                driver: (sqlite3__WEBPACK_IMPORTED_MODULE_0___default().Database)\n            });\n            await this.createTables();\n            this.initialized = true;\n            console.log(\"WalletDatabase initialized successfully\");\n        } catch (error) {\n            throw new Error(`Failed to initialize database: ${error}`);\n        }\n    }\n    async createTables() {\n        if (!this.db) throw new Error(\"Database not available\");\n        await this.db.exec(`\n      CREATE TABLE IF NOT EXISTS wallets (\n        user_id TEXT PRIMARY KEY,\n        wallet_id TEXT NOT NULL,\n        wallet_address TEXT NOT NULL,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n    }\n    async getWallet(userId) {\n        if (!this.db) throw new Error(\"Database not initialized\");\n        const wallet = await this.db.get(\"SELECT * FROM wallets WHERE user_id = ?\", [\n            userId\n        ]);\n        return wallet || null;\n    }\n    async saveWallet(userId, walletId, walletAddress) {\n        if (!this.db) throw new Error(\"Database not initialized\");\n        await this.db.run(\"INSERT OR REPLACE INTO wallets (user_id, wallet_id, wallet_address) VALUES (?, ?, ?)\", [\n            userId,\n            walletId,\n            walletAddress\n        ]);\n    }\n    async getAllWallets() {\n        if (!this.db) throw new Error(\"Database not initialized\");\n        return await this.db.all(\"SELECT * FROM wallets ORDER BY created_at DESC\");\n    }\n    async close() {\n        if (this.db) {\n            await this.db.close();\n            this.db = null;\n            this.initialized = false;\n        }\n    }\n}\nconst walletDB = WalletDatabase.getInstance();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGlicy9XYWxsZXREYXRhYmFzZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4QjtBQUNVO0FBU2pDLE1BQU1FO0lBS1gsYUFBc0I7YUFIZEMsS0FBc0I7YUFDdEJDLGNBQXVCO0lBRVI7SUFFdkIsT0FBT0MsY0FBOEI7UUFDbkMsSUFBSSxDQUFDSCxlQUFlSSxRQUFRLEVBQUU7WUFDNUJKLGVBQWVJLFFBQVEsR0FBRyxJQUFJSjtRQUNoQztRQUNBLE9BQU9BLGVBQWVJLFFBQVE7SUFDaEM7SUFFQSxNQUFNQyxPQUFzQjtRQUMxQixJQUFJLElBQUksQ0FBQ0gsV0FBVyxFQUFFO1FBRXRCLElBQUk7WUFDRixJQUFJLENBQUNELEVBQUUsR0FBRyxNQUFNRiw0Q0FBSUEsQ0FBQztnQkFDbkJPLFVBQVU7Z0JBQ1ZDLFFBQVFULHlEQUFnQjtZQUMxQjtZQUVBLE1BQU0sSUFBSSxDQUFDVyxZQUFZO1lBQ3ZCLElBQUksQ0FBQ1AsV0FBVyxHQUFHO1lBQ25CUSxRQUFRQyxHQUFHLENBQUM7UUFDZCxFQUFFLE9BQU9DLE9BQU87WUFDZCxNQUFNLElBQUlDLE1BQU0sQ0FBQywrQkFBK0IsRUFBRUQsT0FBTztRQUMzRDtJQUNGO0lBRUEsTUFBY0gsZUFBOEI7UUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ1IsRUFBRSxFQUFFLE1BQU0sSUFBSVksTUFBTTtRQUU5QixNQUFNLElBQUksQ0FBQ1osRUFBRSxDQUFDYSxJQUFJLENBQUMsQ0FBQzs7Ozs7OztJQU9wQixDQUFDO0lBQ0g7SUFFQSxNQUFNQyxVQUFVQyxNQUFjLEVBQWdDO1FBQzVELElBQUksQ0FBQyxJQUFJLENBQUNmLEVBQUUsRUFBRSxNQUFNLElBQUlZLE1BQU07UUFFOUIsTUFBTUksU0FBUyxNQUFNLElBQUksQ0FBQ2hCLEVBQUUsQ0FBQ2lCLEdBQUcsQ0FDOUIsMkNBQ0E7WUFBQ0Y7U0FBTztRQUVWLE9BQU9DLFVBQVU7SUFDbkI7SUFFQSxNQUFNRSxXQUNKSCxNQUFjLEVBQ2RJLFFBQWdCLEVBQ2hCQyxhQUFxQixFQUNOO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQ3BCLEVBQUUsRUFBRSxNQUFNLElBQUlZLE1BQU07UUFFOUIsTUFBTSxJQUFJLENBQUNaLEVBQUUsQ0FBQ3FCLEdBQUcsQ0FDZix3RkFDQTtZQUFDTjtZQUFRSTtZQUFVQztTQUFjO0lBRXJDO0lBRUEsTUFBTUUsZ0JBQXlDO1FBQzdDLElBQUksQ0FBQyxJQUFJLENBQUN0QixFQUFFLEVBQUUsTUFBTSxJQUFJWSxNQUFNO1FBRTlCLE9BQU8sTUFBTSxJQUFJLENBQUNaLEVBQUUsQ0FBQ3VCLEdBQUcsQ0FBQztJQUMzQjtJQUVBLE1BQU1DLFFBQXVCO1FBQzNCLElBQUksSUFBSSxDQUFDeEIsRUFBRSxFQUFFO1lBQ1gsTUFBTSxJQUFJLENBQUNBLEVBQUUsQ0FBQ3dCLEtBQUs7WUFDbkIsSUFBSSxDQUFDeEIsRUFBRSxHQUFHO1lBQ1YsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDckI7SUFDRjtBQUNGO0FBRU8sTUFBTXdCLFdBQVcxQixlQUFlRyxXQUFXLEdBQUciLCJzb3VyY2VzIjpbIi9Vc2Vycy9hZG1pbi9Eb2N1bWVudHMvcHJvamVjdHMvbXljZWxpdW0tc2RrL3BhY2thZ2VzL2Zyb250ZW5kL3NyYy9saWJzL1dhbGxldERhdGFiYXNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzcWxpdGUzIGZyb20gXCJzcWxpdGUzXCI7XG5pbXBvcnQgeyBvcGVuLCBEYXRhYmFzZSB9IGZyb20gXCJzcWxpdGVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBXYWxsZXRSZWNvcmQge1xuICB1c2VyX2lkOiBzdHJpbmc7XG4gIHdhbGxldF9pZDogc3RyaW5nO1xuICB3YWxsZXRfYWRkcmVzczogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBXYWxsZXREYXRhYmFzZSB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBXYWxsZXREYXRhYmFzZTtcbiAgcHJpdmF0ZSBkYjogRGF0YWJhc2UgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7fVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBXYWxsZXREYXRhYmFzZSB7XG4gICAgaWYgKCFXYWxsZXREYXRhYmFzZS5pbnN0YW5jZSkge1xuICAgICAgV2FsbGV0RGF0YWJhc2UuaW5zdGFuY2UgPSBuZXcgV2FsbGV0RGF0YWJhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIFdhbGxldERhdGFiYXNlLmluc3RhbmNlO1xuICB9XG5cbiAgYXN5bmMgaW5pdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZGIgPSBhd2FpdCBvcGVuKHtcbiAgICAgICAgZmlsZW5hbWU6IFwiLi93YWxsZXRzLmRiXCIsXG4gICAgICAgIGRyaXZlcjogc3FsaXRlMy5EYXRhYmFzZSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB0aGlzLmNyZWF0ZVRhYmxlcygpO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmxvZyhcIldhbGxldERhdGFiYXNlIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBkYXRhYmFzZTogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRhYmxlcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBhdmFpbGFibGVcIik7XG5cbiAgICBhd2FpdCB0aGlzLmRiLmV4ZWMoYFxuICAgICAgQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgd2FsbGV0cyAoXG4gICAgICAgIHVzZXJfaWQgVEVYVCBQUklNQVJZIEtFWSxcbiAgICAgICAgd2FsbGV0X2lkIFRFWFQgTk9UIE5VTEwsXG4gICAgICAgIHdhbGxldF9hZGRyZXNzIFRFWFQgTk9UIE5VTEwsXG4gICAgICAgIGNyZWF0ZWRfYXQgREFURVRJTUUgREVGQVVMVCBDVVJSRU5UX1RJTUVTVEFNUFxuICAgICAgKVxuICAgIGApO1xuICB9XG5cbiAgYXN5bmMgZ2V0V2FsbGV0KHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxXYWxsZXRSZWNvcmQgfCBudWxsPiB7XG4gICAgaWYgKCF0aGlzLmRiKSB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWRcIik7XG5cbiAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCB0aGlzLmRiLmdldChcbiAgICAgIFwiU0VMRUNUICogRlJPTSB3YWxsZXRzIFdIRVJFIHVzZXJfaWQgPSA/XCIsXG4gICAgICBbdXNlcklkXVxuICAgICk7XG4gICAgcmV0dXJuIHdhbGxldCB8fCBudWxsO1xuICB9XG5cbiAgYXN5bmMgc2F2ZVdhbGxldChcbiAgICB1c2VySWQ6IHN0cmluZyxcbiAgICB3YWxsZXRJZDogc3RyaW5nLFxuICAgIHdhbGxldEFkZHJlc3M6IHN0cmluZ1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcblxuICAgIGF3YWl0IHRoaXMuZGIucnVuKFxuICAgICAgXCJJTlNFUlQgT1IgUkVQTEFDRSBJTlRPIHdhbGxldHMgKHVzZXJfaWQsIHdhbGxldF9pZCwgd2FsbGV0X2FkZHJlc3MpIFZBTFVFUyAoPywgPywgPylcIixcbiAgICAgIFt1c2VySWQsIHdhbGxldElkLCB3YWxsZXRBZGRyZXNzXVxuICAgICk7XG4gIH1cblxuICBhc3luYyBnZXRBbGxXYWxsZXRzKCk6IFByb21pc2U8V2FsbGV0UmVjb3JkW10+IHtcbiAgICBpZiAoIXRoaXMuZGIpIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmRiLmFsbChcIlNFTEVDVCAqIEZST00gd2FsbGV0cyBPUkRFUiBCWSBjcmVhdGVkX2F0IERFU0NcIik7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5kYikge1xuICAgICAgYXdhaXQgdGhpcy5kYi5jbG9zZSgpO1xuICAgICAgdGhpcy5kYiA9IG51bGw7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3YWxsZXREQiA9IFdhbGxldERhdGFiYXNlLmdldEluc3RhbmNlKCk7XG4iXSwibmFtZXMiOlsic3FsaXRlMyIsIm9wZW4iLCJXYWxsZXREYXRhYmFzZSIsImRiIiwiaW5pdGlhbGl6ZWQiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiaW5pdCIsImZpbGVuYW1lIiwiZHJpdmVyIiwiRGF0YWJhc2UiLCJjcmVhdGVUYWJsZXMiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJFcnJvciIsImV4ZWMiLCJnZXRXYWxsZXQiLCJ1c2VySWQiLCJ3YWxsZXQiLCJnZXQiLCJzYXZlV2FsbGV0Iiwid2FsbGV0SWQiLCJ3YWxsZXRBZGRyZXNzIiwicnVuIiwiZ2V0QWxsV2FsbGV0cyIsImFsbCIsImNsb3NlIiwid2FsbGV0REIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/libs/WalletDatabase.ts\n");

/***/ }),

/***/ "(ssr)/../../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \**********************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ }),

/***/ "node:buffer":
/*!******************************!*\
  !*** external "node:buffer" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:buffer");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:http":
/*!****************************!*\
  !*** external "node:http" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:http");

/***/ }),

/***/ "node:https":
/*!*****************************!*\
  !*** external "node:https" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:https");

/***/ }),

/***/ "node:net":
/*!***************************!*\
  !*** external "node:net" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:net");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),

/***/ "node:zlib":
/*!****************************!*\
  !*** external "node:zlib" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:zlib");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "sqlite3":
/*!**************************!*\
  !*** external "sqlite3" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("sqlite3");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/viem","vendor-chunks/@noble","vendor-chunks/node-fetch-native","vendor-chunks/libphonenumber-js","vendor-chunks/ox","vendor-chunks/svix","vendor-chunks/@hpke","vendor-chunks/zod","vendor-chunks/jose","vendor-chunks/@privy-io","vendor-chunks/abitype","vendor-chunks/@scure","vendor-chunks/ts-case-convert","vendor-chunks/uuid","vendor-chunks/fast-sha256","vendor-chunks/@stablelib","vendor-chunks/base-x","vendor-chunks/redaxios","vendor-chunks/canonicalize","vendor-chunks/bs58","vendor-chunks/sqlite"], () => (__webpack_exec__("(rsc)/../../node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fsdk%2Fcreate-wallet%2Froute&page=%2Fapi%2Fsdk%2Fcreate-wallet%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fsdk%2Fcreate-wallet%2Froute.ts&appDir=%2FUsers%2Fadmin%2FDocuments%2Fprojects%2Fmycelium-sdk%2Fpackages%2Ffrontend%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fadmin%2FDocuments%2Fprojects%2Fmycelium-sdk%2Fpackages%2Ffrontend&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();